<!--
	作者：Sariay
	时间：2018-09-25
	描述：There may be a bug, but don't worry, QiLing(器灵) says that it can work normally!
-->

	<!DOCTYPE html>
	<html class="scrollbar">
		

<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      面试宝典一 | 前端进阶之路
    
  </title>
  <meta name="author" content="FXC">
  <meta name="keywords" content>
  <meta name="description" content>
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

    <!-- jquery -->
	<script src="/js/jquery-2.1.1.min.js"></script>

  <!-- leancloud -->
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script src="/js/leancloud.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="transition">
					<div class="three-bounce1"></div>
					<div class="three-bounce2"></div>
					<div class="three-bounce3"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground" data-img-mode="normal" data-normal-src="/img/wolf.jpg" data-random-max="110" data-random-src="https://sariay.github.io/Random-img/">
	<div class="mask">
		<div class="h-header">
			<div id="logo-S">
				
					<a href="/">
						<img src="/img/logo.png" alt="Logo">
					</a>
				
			</div>
			<!-- Navigation in header(id="navigation-S") -->
			<div id="navigation-S">
				<ul>
					
						<li class="menu-home">
							<a href="/" class="menu-item-home">主页</a>
						</li>
					
						<li class="menu-archive">
							<a href="/archives" class="menu-item-archive">归档</a>
						</li>
					
						<li class="menu-categories">
							<a href="/categories" class="menu-item-categories">分类</a>
						</li>
					
						<li class="menu-tags">
							<a href="/tags" class="menu-item-tags">标签</a>
						</li>
					
						<li class="menu-about">
							<a href="/about" class="menu-item-about">关于</a>
						</li>
					

					
						<li class="menu-search">
							<a href="javascript:;" class="popup-trigger" title="Search">搜索</a>
						</li>
					
				</ul>			
			</div>				
		</div>

		<div class="h-body">	
			<!-- motto -->
			
				<div id="page-motto">
					<p class="motto">
						
					</p>
				</div>
			

			<div id="navigation-H">
				<!-- Page title -->
				<p>
					
						当前文章&nbsp;:&nbsp;《面试宝典一》
					
				</p>
				<!-- Progress bar -->
				<div id="progress-bar"></div>

				<!-- Progress percent -->
				<div id="progress-percentage">
					<h1>0.0%</h1>
				</div>
			</div>
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<ul>
				<!-- <li>
					<a><i class="fa fa-camera-retro" onclick="changeHeaderBg()"></i>切换背景</a>
				</li> -->
				<li>
					<a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down"></i>继续阅读</a>
				</li>
				<!-- <li>
					<a href="https://github.com/Sariay/hexo-theme-Annie" target="_blank"><i class="fa fa-download"></i>克隆主题</a>
				</li> -->
			</ul>
		</div>
		
		<!-- This is only a demo, please go to "https://time.is" to set your city time! -->
<style type="text/css">
	.header-date {
		position: absolute;
		left: 40px;
		bottom: 30px;
		writing-mode: tb-rl;
		font-size: 36px;
	}	
	.header-date a {
		border-bottom: none;
	}
	@media only screen and (max-width: 768 ) {
		.header-date {
			position: absolute;
			left: 40px;
			bottom: 30px;
			writing-mode: tb-rl;
			font-size: 20px;
		}			
	}
</style>
<div class="header-date">
	<a href="https://time.is/Beijing" id="time_is_link" rel="nofollow"></a>
	<span id="Beijing_z43d"></span>
</div>
<script src="//widget.time.is/zh.js"></script>
<script>
	time_is_widget.init({
		Beijing_z43d:{
			template:"DATE", 
			date_format:"year年 monthname dnum日"
		}
	});
</script>
</div></header>

<!-- Navigation in div(id="navigation-H") -->
<a class="nav-trigger">
	<span></span>
</a>

<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<h3>Navigation</h3>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	<div class="nav-body">
		<ul>
			
				<li class="menu-home">
					<a href="/" class="menu-item-home">主页</a>
				</li>
			
				<li class="menu-archive">
					<a href="/archives" class="menu-item-archive">归档</a>
				</li>
			
				<li class="menu-categories">
					<a href="/categories" class="menu-item-categories">分类</a>
				</li>
			
				<li class="menu-tags">
					<a href="/tags" class="menu-item-tags">标签</a>
				</li>
			
				<li class="menu-about">
					<a href="/about" class="menu-item-about">关于</a>
				</li>
			

			
				<li class="menu-search">
					<a href="javascript:;" class="popup-trigger" title="Search">搜索</a>
				</li>
			
		</ul>
	</div>

	<div class="nav-footer">
		<ul>
	
		
			<li>
				<a href="https://github.com/ccOnTheWay/wiki" title="Github" target="_blank">
					<i class="fa fa-github"></i>
				</a>
			</li>
		
		
		
			<li>
				<a href="mailto:fengxicai@fengxicai.cn" title="Email" target="_blank">
					<i class="fa fa-envelope-o"></i>
				</a>
			</li>
		

		
		
	 
</ul>
	</div>
</nav>

		
		<!--main-->
		<main>
			<div class="layout-post">
	
	
	<div class="article-title">
		
	<a href="/2019/03/27/面试宝典一/" itemprop="url">
		面试宝典一
	</a>

	</div>

	<div class="article-meta">
		<span>
			
	发布于
	<a href="/2019/03/27/面试宝典一/" itemprop="url">
		<time datetime="2019-03-27T03:37:09.000Z" itemprop="datePublished">
	  		2019-03-27
	  </time>
	</a> 

	/
	更新于
	<a href="/2019/03/27/面试宝典一/" itemprop="url">
		<time datetime="2019-03-27T03:37:09.000Z" itemprop="dateUpdated">
	  		2019-03-27
	  </time>
	</a> 	

		</span>
		/
		<span>
			<i class="fa fa-tags"></i>
			
	
		<a href="/tags/面试手册/" class=" ">
			面试手册
		</a>
	
		
		</span>
		/
		

    <span class="leancloud_visitors" id="/2019/03/27/面试宝典一/_visitors" data-url="/2019/03/27/面试宝典一/" data-title="面试宝典一">
        热度
        <i class="leancloud_visitors_count" id="leancloud_visitors_count">0</i>
    </span>
    
    /



    <span class="leancloud_likes" id="/2019/03/27/面试宝典一/_likes" data-url="/2019/03/27/面试宝典一/" data-title="面试宝典一" rel="unlike">
        喜欢
        <i class="fa fa-heart"></i>
        <i class="leancloud_likes_count" id="leancloud_likes_count">0</i>
    </span>

	</div>

	<div class="article-content" id="article-content">
		<p>HTML5面试题<br>一、    Doctype的作用? 严格模式和混杂模式的区分，以及如何触发这2种模式?<br><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。<br>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。<br>严格模式就是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，<br>混杂模式是一种向后兼容的解析方法。<br>触发标准模式或者说严格模式很简单，就是Html前申明正确的DTD，出发混杂模式可以在html文档开始不声明DTD，或者在DOCTYPE前加入XML声明<br>二、    请写出至少20个HTML5标签</p>
<pre><code>&lt;article&gt;  &lt;aside&gt;  &lt;audio&gt;  &lt;canvas&gt;  &lt;datalist&gt;  &lt;command&gt;  &lt;details&gt; &lt;embed&gt;  &lt;figcaption&gt;  &lt;figure&gt;  &lt;footer&gt;  &lt;header&gt;  &lt;hgroup&gt;  &lt;keygen&gt;  &lt;mark&gt;  &lt;nav&gt;  &lt;section&gt;  &lt;time&gt;  &lt;video&gt;  &lt;summary&gt;  &lt;meter&gt;  &lt;output&gt;  &lt;progress&gt;  &lt;source&gt;
`
</code></pre><p>三、    语义化的理解？<br>1.html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>2.在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。<br>3.搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。<br>4.使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。<br>四、    列举5种IE  haslayout的属性及其值<br>haslayout 是Windows Internet Explorer渲染引擎的一个内部组成部分。在Internet Explorer中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。为了调节这两个不同的概念，渲染引擎采用 了 hasLayout 的属性，属性值可以为true或false。当一个元素的 hasLayout 属性值为true时，我们说这个元素有一个布局（layout）<br>部分的 IE 显示的错误，都可以通过激发元素的 haslayout 属性来修正。可以通过设置 css 尺寸属性(width/height)等来激发元素的 haslayout，使其“拥有布局”。如下所示，通过设置以下 css 属性即可。</p>
<ul>
<li>display: inline一block<ul>
<li>height: (任何值除了auto)</li>
<li>float: (left 或 right)</li>
<li>position: absolute</li>
<li>width: (任何值除了auto)</li>
<li>writing一mode: tb一rl；（实现文字可以垂直显示，具体意义可百度了解）</li>
<li>zoom: (除 normal 外任意值)<br>Internet Explorer 7 还有一些额外的属性(不完全列表):</li>
</ul>
</li>
<li>min一height: (任意值)<ul>
<li>max一height: (除 none 外任意值)</li>
<li>min一width: (任意值)</li>
<li>max一width: (除 none 外任意值)</li>
<li>overflow: (除 visible 外任意值)</li>
<li>overflow一x: (除 visible 外任意值)</li>
<li>overflow一y: (除 visible 外任意值)</li>
<li>position: fixed</li>
</ul>
</li>
</ul>
<p>五、    简述jpg，gif，png-8，png-24的区别，及其各自的使用场景<br>gif、jpg、png格式的图片在网站制作中的区别<br>Gif格式特点:<br>　　1.透明性,Gif是一种布尔透明类型，既它可以是全透明，也可以是全不透明，但是它并没有半透明（alpha透明）。<br>　　2.动画,Gif这种格式支持动画。<br>　　3.无损耗性,Gif是一种无损耗的图像格式，这也意味着你可以对gif图片做任何操作也不会使得图像质量产生损耗。<br>　　4.水平扫描,Gif是使用了一种叫作LZW的算法进行压缩的，当压缩gif的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的gif图片比竖向的gif图片更加小。例如500<em>10的图片比10</em>500的图片更加小<br>　　5.间隔渐进显示,Gif支持可选择性的间隔渐进显示<br>　　由以上特点看出只有256种颜色的gif图片不适合照片，但它适合对颜色要求不高的图形（比如说图标，图表等），它并不是最优的选择，我们会在后面中看到png是最优的选择。</p>
<p>Jpeg（jpg）格式特点:<br>　　1.透明性,它并不支持透明。<br>　　2.动画,它也不支持动画。<br>　　3.损耗性,除了一些比如说旋转（仅仅是90、180、270度旋转），裁切，从标准类型到先进类型，编辑图片的原数据之外，所有其它操作对jpeg图像的处理都会使得它的质量损失。所以我们在编辑过程一般用png作为过渡格式。<br>　　4.隔行渐进显示,它支持隔行渐进显示（但是ie浏览器并不支持这个属性，但是ie会在整个图像信息完全到达的时候显示）。<br>　　由上可以看出Jpeg是最适web上面的摄影图片和数字照相机中。<br>　　Png格式特点:<br>　　1.类型,Png这种图片格式包括了许多子类，但是在实践中大致可以分为256色的png和全色的png，你完成可以用256色的png代替gif，用全色的png代替jpeg<br>　　2.透明性,Png是完全支持alpha透明的（透明，半透明，不透明），尽管有两个怪异的现象在ie6（下面详细讨论）<br>　　3.动画,它不支持动画<br>　　PNG图片格式现在包含三种类型：<br>　　1.PNG8256色PNG的别名<br>　　2.PNG24全色PNG的别名<br>　　3.PNG32全色PNG的别名<br>　　基本上PNG32就是PNG24，但是附带了全alpha通道。就是说每个像素上不仅存储了24位真色彩信息还存储了8位的alpha通道信息，就如同GIF能存储透明和不透明信息一样。当我们把图片放到不太搭配的背景上的时候，透明PNG图片的边缘会显示得更加平滑。<br>　　当然，我也知道你的想法，“但是Photoshop也能生成带透明通道的PNG图片！”我也知道，它只是表面上这么说是PNG24，让我也产生困惑了。<br>　　作为一个伤感的Fireworks倡导者，我只使用PNG32支持附带alpha通道的真色彩图片。不管怎样，如果你习惯使用Photoshop，你就应该知道，Photoshop在“存储为WEB格式”中只提供PNG8和PNG24两种PNG格式。<br>　　我敢肯定你经常会勾选“支持透明”选项，以获得带有透明度的PNG图片，但是这样你就获取了一张PNG32图片。——Photoshop只是觉得把PNG32这个名称给隐藏掉了。。。。</p>
<p>对png8的误解<br>　　Png8的在ie中的怪异表现：<br>　　半透明的png8在ie6以下的浏览器显示为全透明。<br>　　Alpha透明的全色PNG（png32）在ie6中会出现背景颜色（通常是灰色）。<br>　　由上面可以总结：<br>　　（a）全透明的png8可以在任一浏览器正常显示（就像gif一样）。半透明的png8在除了ie6及其以下的浏览器下错误的显示成全透明，其它浏览器都能正常显示半透明。这个bug并不需要特殊对待，因为在不支持半透明的浏览器下只是显示为全透明，对用户体验影响不大，它反而是透明gif的加强版。<br>　　（b）第二个bug没有什么好的方法解决，只能通过影响性能的方法AlphaImageLoader与需要加特殊标签（VML）。<br>　　因此得出结论就是：请使用PNG8。<br>Png8的软件问题：<br>　　Photoshop只能导出布尔透明的PNG8。<br>　　Fireworks既能导出布尔透明的PNG8，也能导出alpha透明的PNG8.<br>六、    能够设置文本加粗的样式属性是什么<br>字体加粗（font一weight） 　　<br>功能：用于设置字体笔划的粗细。 　　<br>属性值：正常度 一 normal 　　<br>相对度 一 bold, bolder, light, lighter 　　<br>渐变度 一 100, 200, 300, 400(相当于normal), 500, 600, 700(相当于 bold、 lighter、 bolder、以及数值100－900。 　　<br>语法为：h1 {font一weight: 属性值}<br>七、    Html和xhtml有什么区别?<br>html是一种基本的web网页设计语言，xhtml是一个基于XML的置标语言。<br>最主要的不同:<br>XHTML元素必须正确的被嵌套，元素必须关闭，标签必须小写，必须有根元素。<br>八、    算法题：有一个长度为n一1的数组，包含1一n中不重复的乱序的数，求寻找范围内不在数组中的数，考虑空间占用，性能优化，溢出等情况，至少写两个算法<br> 当n不太大时，可以考虑求和。先算出1~n的所有数的和，然后减去数组中出现的所有自然数的和。时间复杂度为O(n)，空间复杂度O(1)。这种方法的缺点是n不能太大，n比较大时，求和容易溢出。<br>用位图。从头到尾的扫描整个数组，把出现的数相应的位设置为1.然后再扫描位图，找出不为1的那一位，即为要找的数。这种方法的时间复杂度为O(n),空间复杂度为O(n)。<br>异或有个很巧妙的地方：同一变量和该变量与另一变量的异或值的异或等于这个变量自身。所以我们可以把1~n的所有数异或，再把数组中出现的所有数异或，然后再把这两个异或的结果异或，最后得到的值即为我们要找的值。这样时间复杂度为O(n),空间复杂度为O（1）。在空间上比第二种方法要好，而且不会出现第一种方法中所说的溢出问题。<br>九、    实现以下方法（与标准一致）</p>
<pre><code>Element.prototype.getElementsByClassName：
Element.prototype.getElementsByClassName = function(searchClass, node, tag) {
    if (document.getElementsByClassName) {
        var nodes = (node || document).getElementsByClassName(searchClass), 
            result = [];
        for (var i = 0; node = nodes[i++]; ) {
            if (tag !== &quot;*&quot; &amp;&amp; node.tagName === tag.toUpperCase()) {
                result.push(node);
            }
        }
        return result;
    } else {
        node = node || document;
        tag = tag || &quot;*&quot;;
        var classes = searchClass.split(&quot; &quot;), 
            elements = (tag === &quot;*&quot; &amp;&amp; node.all) ? node.all : node.getElementsByTagName(tag), 
            patterns = [], 
            current, 
            match;
        var i = classes.length;
        while (一一i &gt;= 0) {
            patterns.push(new RegExp(&quot;(^|\\s)&quot; + classes[i] + &quot;(\\s|$)&quot;));
        }
        var j = elements.length;
        while (一一j &gt;= 0) {
            current = elements[j];
            match = false;
            for (var k = 0, kl = patterns.length; k &lt; kl; k++) {
                match = patterns[k].test(current.className);
                if (!match)
                    break;
            }
            if (match)
                result.push(current);
        }
        return result;
    }
}
Function.prototype.bind：
Function.prototype.bind = function (oThis) {
    if (typeof this !== &quot;function&quot;) {
        throw new TypeError(&quot;bind function error&quot;);
    }
    var aArgs = Array.prototype.slice.call(arguments,1),
        fToBind = this, 
        fBound = function () {
            return fToBind.apply(oThis || window,aArgs.concat(Array.prototype.slice.call(arguments)));
        };
    return fBound;
};

</code></pre><p>十、    编写一个方法去掉一个数组的重复元素<br>1.遍历数组法<br>最简单的去重方法， 实现思路：新建一新数组，遍历传入数组，值不在新数组就加入该新数组中；注意点：判断值是否在数组的方法“indexOf”是ECMAScript5 方法，IE8以下不支持，需多写一些兼容低版本浏览器代码，源码如下：</p>
<pre><code>// 最简单数组去重法
function unique1(array){
  var n = [ ]; //一个新的临时数组
  //遍历当前数组
  for(var i = 0; i &lt; array.length; i++){
    //如果当前数组的第i已经保存进了临时数组，那么跳过，
    //否则把当前项push到临时数组里面
    if (n.indexOf(array[i]) == 一1) n.push(array[i]);
  }
  return n;
}
// 判断浏览器是否支持indexOf ，indexOf 为ecmaScript5新方法 IE8以下（包括IE8， IE8只支持部分ecma5）不支持
if (!Array.prototype.indexOf){
  // 新增indexOf方法
  Array.prototype.indexOf = function(item){
    var result = 一1, a_item = null;
    if (this.length == 0){
      return result;
    }
    for(var i = 0, len = this.length; i &lt; len; i++){
      a_item = this[i];
      if (a_item === item){
        result = i;
        break;
      }  
    }
    return result;
  }
}
</code></pre><p>2.对象键值对法<br>该方法执行的速度比其他任何方法都快， 就是占用的内存大一些；实现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入新数组。注意点： 判断是否为js对象键时，会自动对传入的键执行“toString()”，不同的键可能会被误认为一样；例如： a[1]、a[“1”] 。解决上述问题还是得调用“indexOf”。</p>
<pre><code>// 速度最快， 占空间最多（空间换时间）
function unique2(array){
  var n = {}, r = [], len = array.length, val, type;
    for (var i = 0; i &lt; array.length; i++) {
        val = array[i];
        type = typeof val;
        if (!n[val]) {
            n[val] = [type];
            r.push(val);
        } else if (n[val].indexOf(type) &lt; 0) {
            n[val].push(type);
            r.push(val);
        }
    }
    return r;
}
</code></pre><p>3.数组下标判断法<br>还是得调用“indexOf”性能跟方法1差不多，实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。</p>
<pre><code>function unique3(array){
  var n = [array[0]]; //结果数组
  //从第二项开始遍历
  for(var i = 1; i &lt; array.length; i++) {
    //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
    //那么表示第i项是重复的，忽略掉。否则存入结果数组
    if (array.indexOf(array[i]) == i) n.push(array[i]);
  }
  return n;
}
</code></pre><p>4.排序后相邻去除法<br>虽然原生数组的”sort”方法排序结果不怎么靠谱，但在不注重顺序的去重里该缺点毫无影响。实现思路：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。</p>
<pre><code>// 将相同的值相邻，然后遍历去除重复值
function unique4(array){
  array.sort(); 
  var re=[array[0]];
  for(var i = 1; i &lt; array.length; i++){
    if( array[i] !== re[re.length一1])
    {
      re.push(array[i]);
    }
  }
  return re;
}
</code></pre><p>5.优化遍历数组法<br>实现思路：获取没重复的最右一值放入新数组。（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）</p>
<pre><code>// 思路：获取没重复的最右一值放入新数组
function unique5(array){
  var r = [];
  for(var i = 0, l = array.length; i &lt; l; i++) {
    for(var j = i + 1; j &lt; l; j++)
      if (array[i] === array[j]) j = ++i;
    r.push(array[i]);
  }
  return r;
}
</code></pre><p>十一、    请使用javascript写出数组快速排序代码</p>
<pre><code>&lt;script&gt;
function quiktSort(arr){
        var  left =[],right=[];
        if(arr.length&lt;1){
            return  arr;
        }
        var  index = Math.floor(arr.length/2);
        var  point = arr.splice(index,1);
        for(var i=0,len=arr.length;i&lt;len;i++){
            if(arr[i]&lt;point){
        left.push(arr[i]);
}else{
    right.push(arr[i]);
}
        }
        return quickSort(left).concat(point,quickSort(right));
    }
&lt;/script&gt;
</code></pre><p>十二、    编写一个布局，页面宽度自适应，最小宽度300px，左边定宽35%，右边定宽65%</p>
<p><div class="container"><br>        <div class="left"></div><br>        <div class="right"></div><br>    </div><br>    <style><br>        .container{<br>            height: 600px;<br>            _width: 300px;  // 加下划线ie6兼容<br>            min一width: 300px;<br>        }<br>        .left{<br>            width: 35%;<br>            height: 100%;<br>            background: #ff0;<br>            float: left;<br>        }<br>        .right{<br>            overflow:hidden;<br>            width: 65%;<br>            height: 100%;<br>            background: #0f0;<br>        }<br>    </style><br>十三、    谈谈对html5的了解<br>1.良好的移动性，以移动设备为主。<br>2.响应式设计，以适应自动变化的屏幕尺寸<br>3.支持离线缓存技术，webStorage本地缓存<br>4.新增canvas，video，audio等新标签元素。新增特殊内容元素：article，footer，header，nav，section等，新增表单控件：calendar，date，time，email，url，search。<br>5.地理定位…<br>6.新增webSocket/webWork技术<br>十四、    Js面向对象的几种方式<br>1.对象的字面量 var obj = {}<br>2.创建实例对象 var obj = new Object();<br>3.构造函数模式 function fn(){} , new fn();<br>4.工厂模式：用一个函数，通过传递参数返回对象。function fn(params){var obj =new Object();obj.params = params; return obj;},fn(params);<br>5.原型模式：function clock(hour){} fn.prototype.hour = 0; new clock();<br>首先，每个函数都有一个prototype(原型)属性，这个指针指向的就是clock.prototype对象。而这个原型对象在默认的时候有一个属性constructor，指向clock，这个属性可读可写。而当我们在实例化一个对象的时候，实例newClock除了具有构造函数定义的属性和方法外（注意，只是构造函数中的）,还有一个指向构造函数的原型的指针，ECMAScript管他叫[[prototype]]，这样实例化对象的时候，原型对象的方法并没有在某个具体的实例中，因为原型没有被实例。<br>十五、    在css中哪个属性会影响dom读取文档流的顺序<br>1.direction, writing一mode<br>十六、    前端页面由哪三层构成，分别是什么，作用是什么<br>Html (结构) : 超文本标记语言, 由 HTML 或 xhtml之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：“这是一个文本段。”<br>Css (表现) : 层叠样式表 , 由css负责创建。css对“如何显示有关内容”的问题做出了回答。<br>Js (行为) : 客户端脚本语言 , 内容应该如何对事件做出反应<br>十七、    Css的基本语句构成是？<br>语法:<br>（自定义的样式名称）｛<br>    样式内容（属性：属性值；）<br>｝<br>十八、    如何对网站的文件和资源进行优化<br>1．文件合并（目的是减少http请求）<br>2．文件压缩 （目的是直接减少文件下载的体积）<br>3．使用cdn托管资源<br>4．使用缓存<br>5．gizp压缩需要的js和css文件<br>6．meta标签优化（title,description,keywords）,heading标签的优化,alt优化<br>7．反向链接，网站外链接优化<br>十九、    Javascipt的本地对象，内置对象和宿主对象<br>本地对象：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError, 简单来说，本地对象就是 ECMA一262 定义的类.<br>内置对象：ECMA一262 把内置对象（built一in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。<br>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA一262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。<br>如此就可以理解了。内置对象是本地对象的一种。而其包含的两种对象中，Math对象我们经常用到，可这个Global对象是啥东西呢？<br>Global对象是ECMAScript中最特别的对象，因为实际上它根本不存在，有点玩人的意思。大家要清楚，在ECMAScript中，不存在独立的函数，所有函数都必须是某个对象的方法。<br>类似于isNaN()、parseInt()和parseFloat()方法等，看起来都是函数，而实际上，它们都是Global对象的方法。而且Global对象的方法还不止这些.<br>宿主对象: ECMAScript中的“宿主”就是我们网页的运行环境，即“操作系统”和“浏览器”。所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM对象都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。自定义的对象也是宿主对象。<br>二十、    输入url后的加载过程<br>1)    查找域名对应IP地址<br>2)    建立连接(TCP的三次握手)<br>3)    构建网页<br>4)    断开连接(TCP的四次挥手)<br>二十一、    说说TCP传输的三次握手四次挥手策略<br>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。<br>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。<br>最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。<br>断开一个TCP连接则需要“四次挥手”：<br>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。<br>二十二、    JQuery中有几种类型的选择器<br>1.层叠选择器$(“form  input”)<br>2.基本过滤选择器 :first  :last :not()<br>3.内容过滤选择器:odd:eq():animated<br>4.可视化过滤选择器 :hidden :visible<br>5.属性过滤选择器：div[id]<br>6.子元素过滤选择器:first一child :last一child :only :child<br>7.表单元素过滤选择器 :enabled :disabled :checked :selected<br>8.id,类，类型,元素…<br>二十三、    jQuery中的Delegate()函数有什么作用<br>delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。<br>使用 delegate() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。$(“div”).delegate(“button”,”click”,function(){<br>  $(“p”).slideToggle();});<br>二十四、    行内元素有那些。块级元素有那些。空元素有哪些<br>首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素； span默认display属性值为“inline”，是“行内”元素。<br>（1）行内元素有：a b span select strong（强调的语气）img input（内联元素）<br>（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p<br>（3）常见的空元素：</p>
<pre><code>    &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;
</code></pre><pre><code>鲜为人知的是：
</code></pre><pre><code>    &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;
</code></pre><p>二十五、    说几条javasprit的基本规范</p>
<p>1.不要在同一行声明多个变量。<br>2.请使用 ===/!==来比较true/false或者数值<br>3.使用对象字面量替代new Array这种形式<br>4.不要使用全局函数。<br>5.Switch语句必须带有default分支<br>6.函数不应该有时候有返回值，有时候没有返回值。<br>7.For循环必须使用大括号<br>8.If语句必须使用大括号<br>9.for一in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。<br>二十六、    介绍一下标准的css盒模型，低版本ie盒模型有什么不同<br>（1）盒模型有两种， IE 盒子模型、W3C 盒子模型；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的width部分把 border 和 padding计算了进去;<br>二十七、    说出三种减少页面加载的方法（加载时间指感知的时间或实际加载的时间）<br>CSS Sprites；<br>JS、CSS源码压缩、图片大小控制合适；<br>网页Gzip；<br>CDN托管；<br>data缓存 ；<br>图片服务器；<br>二十八、    用js代码简单的介绍下自己</p>
<pre><code>&lt;script&gt;
    function Person(name,jingli,jineng) {
      this.name=name;
      this.jingli=jingli;
      this.jineng=jineng;
    }
    Person.prototype.show=function(){
      console.log(&quot;我是&quot;+this.name+&quot;；我有如下经历:&quot;+this.jingli+&quot;；我会如下技能：&quot;+this.jineng);
    }
    var myself=new Person(&quot;小田&quot;,&quot;小田工作室创办人，凤翔网络推广顾问&quot;,&quot;熟悉前端基本技能，熟悉网络营销思想有实战经验，掌握项目经理技能，可以编写文档，也可以使用axure进行原型设计，掌握自动化测试和性能测试技能&quot;)
    myself.show();
  &lt;/script&gt;
</code></pre><p>二十九、    Html5中datalist是什么</p>
<datalist> 标签定义选项列表，与 input 元素配合使用该元素，来定义 input 可能的值。<br>datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。<br></datalist><input id="myCar" list="cars"><br><datalist id="cars"><br>  <option value="BMW"><br>  </option><option value="Ford"><br>  </option><option value="Volvo"><br></option></datalist>

<p>三十、    Ajax同步和异步的区别，如何解决跨域问题<br>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.<br>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。<br>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。<br><code>jsonp、 iframe、window.name、window.postMessage、</code>服务器上设置代理页面</p>
<p>三十一、    列举几种后端通讯的方法及其使用的场景，关于跨域的理解。<br>1.后端程序可以通过session来进行通讯，session有过期时间，主要用于验证码的验证，登录过期等的应用。<br>2.数据库，数据库支持多种语言的操作，那么通过数据库就可以通讯。<br>关于跨域：<br>跨域请求存在的原因：由于浏览器的同源策略，即属于不同域的页面之间不能相互访问各自的页面内容。<br>跨域的场景：<br>1.域名不同 <a href="http://www.yangwei.com" target="_blank" rel="noopener">www.yangwei.com</a> 和<a href="http://www.wuyu.com" target="_blank" rel="noopener">www.wuyu.com</a> 即为不同的域名）<br>2.二级域名相同，子域名不同（<a href="http://www.wuhan.yangwei.com" target="_blank" rel="noopener">www.wuhan.yangwei.com</a> <a href="http://www.shenzheng.yangwei.com" target="_blank" rel="noopener">www.shenzheng.yangwei.com</a> 为子域不同）<br>3.端口不同，协议不同  （ <a href="http://www.yangwei.com" target="_blank" rel="noopener">http://www.yangwei.com</a> 和<a href="https://www.yangwei.com属于跨域www.yangwei.con:8888和www.yangwei.con:8080" target="_blank" rel="noopener">https://www.yangwei.com属于跨域www.yangwei.con:8888和www.yangwei.con:8080</a>)<br>跨域的方式：（内容较多，需掌握CORS和jsonp，其他内容也要了解）<br>1.前端的方式: possMessage，window.name,document.domain,image.src(得不到数据返回)，jsonP(script.src后台不配合得不到数据返回)，style.href（得不到数据返回)<br>一.image.src,script.src,style.href 不受同源策略的影响可以加载其他域的资源，可以用这个特性，向服务器发送数据。最常用的就是使用image.src 向服务器发送前端的错误信息。image.src 和style.href 是无法获取服务器的数据返回的，script.src 服务器端配合可以得到数据返回。<br>二possMessage,window.name,document.domain 是两个窗口直接相互传递数据。<br>（1）possMessage 是HTML5中新增的，使用限制是 必须获得窗口的window 引用。IE8+支持，firefox，chrome,safair,opera支持<br> （2）window.name ，在一个页面中打开另一个页面时，window.name 是共享的，所以可以通过window.name 来传递数据，window.name的限制大小是2M，这个所有浏览器都支持,且没有什么限制。<br>3） document.domain 将两个页面的document.domain 设置成相同，document.domain 只能设置成父级域名，既可以访问，使用限制：这顶级域名必须相同<br>2.纯后端方式: CORS，服务器代理<br>CORS 是w3c标准的方式，通过在web服务器端设置：响应头Access一Cntrol一Alow一Origin 来指定哪些域可以访问本域的数据，ie8&amp;9(XDomainRequest),10+,chrom4 ，firefox3.5,safair4，opera12支持这种方式。<br>服务器代理，同源策略只存在浏览器端，通过服务器转发请求可以达到跨域请求的目的，劣势：增加服务器的负担，且访问速度慢。<br>3.前后端结合:JsonP<br>script.src 不受同源策略的限制，所以可以动态的创建script标签，将要请求数据的域写在src 中参数中附带回调的方法，服务器端返回回调函数的字符串，并带参数。<br>如 script.src=”<a href="http://www.yangwei.com/?id=001&amp;callback=getInfoCallback&quot;,服务器端返回" target="_blank" rel="noopener">http://www.yangwei.com/?id=001&amp;callback=getInfoCallback&quot;,服务器端返回</a> getInfoCallBack(“name:yangwei;age:18”) 这段代码会直接执行，在前面定义好getInfoCallBack函数，既可以获得数据并解析。 这种是最常见的方式。<br>4.webSocket（了解性拓展）<br>服务端推送websocket和sse场景及应用<br>应用场景<br>都可以进行服务端推送,并且都是使用长连接来进行.但两者的实现又有一点不同,sse仍使用http协议,并且使用相同的链接发送正常的http协议报文.而websocket是使用http协议进行握手,然后再使用同一个链接进行websocket协议的通信.<br>websocket可以进行双向的通信,即服务端可以往客户端发信息,客户端也可以向服务端发信息.而sse是单向的,只能由服务端往客户端发.<br>websocket自带连接的保持,即通过ping/pong协议保证连接可以始终维持,sse没有这个保证,不过可以参考ping/pong协议,自己周期性地发送信息来同样地进行处理.比如,5秒往客户端发一个特别的信息(通过type/name进行区分).其次,因为是基于浏览器的使用,sse有一个特性,就是浏览器发现一个连接断掉了,就会自动地进行重联,即重新发送请求.这样,服务端也不用担心连接被断开,不过需要处理新的请求必须和上一次请求的内容相连续,以及新的推送注册.<br>因为都是使用http协议进行起始处理,因此在签权上都可以使用到http协议本身的一些东西,比如header/cookie签权.在相应的握手阶段,通过读取cookie(session)来保证相应的请求必须是经过授权的,也可以用于定位使用人.甚至可以通过这些信息保证单个用户只能有一个请求,避免重复请求<br>由于都是基于浏览器使用,因此建议的数据传输都是文本型.虽然websocket支持二进制frame传输,不过一些都不建议使用.sse只能传输文本<br>不管是websocket还是sse,在用于通信时,都建议只用于进行数据的推送,而不是进行完整的应用处理.这里可以理解为,常规的业务处理仍然交给后端的服务来处理.这样,即可以使用之前的业务开发的优势,又可以使用推送的优势.而不是走向另一个级端,即所有的信息都想通过推送来传递.<br>开发方式<br>websocket开发首选netty,因为netty对协议的封装已经做到了完全的支持.通过 HttpServerCodec作为握手协议,WebSocketServerProtocolHandler作为协议处理,然后再加一个自己的handler,就完成了相应的业务处理.同时在性能上,netty在一个ws的请求建立起来之后,会自动地去除httpServerCodec相关的handler,这样保证后续的处理都是按照ws的协议来进行.<br>sse开发首选jersey,jersey一media一sse提供了相应的sse支持,并且通过与rest相集成,开发一个sse就跟普通的业务开发相同.<br>ws和sse在文本支持上都只支持utf一8编码,因此在处理上需要注册编码方式.同时在使用sse时,如果后端第一次进行响应时,相应的编码不对.chrome会直接报错,包括utf8都会报错(这是之前后端开发的一个问题),可以修正或者增加相应的拦截器,保证后端content一type响应中的charset=UTF一8.<br>ws和sse都可以通过nginx进行代理转发.ws的处理只需要设置http版本,以及重新转发前端的Upgrade和Connection头即可.而sse,也可以通过禁用buffer来处理.参考 <a href="http://stackoverflow.com/questions/27898622/server一sent一events一stopped一work一after一enabling一ssl一on一proxy" target="_blank" rel="noopener">http://stackoverflow.com/questions/27898622/server一sent一events一stopped一work一after一enabling一ssl一on一proxy</a><br>特定实现<br>为保证在开发时推送类的和业务类的系统不会耦合在一起,或者同一个应用内有两种处理模式的功能存在.建议直接在系统层就开发2个不同的系统,一个专门用于推送,另一个用于相应的业务处理.然后业务处理后的数据,需要再交由推送处理,则可以在后端进行通过消息系统进行中转,如kafka(持久保证)或redis(内存订阅)等<br>因为二者在ie上的支持都很有限,因此不建议在ie上进行尝试<br>使用sse还是websocket,取决于是否需要前台交互,还取决于对后端的支持技术的了解程序.比如,了解jersey多一点,还是netty多一点.由于最近netty进行微服务化底层通信支持越来越流行,个人更倾向于使用websocket.但如果仅仅是一个简单的推送功能,又不希望修改代码,那也可以使用jersey(毕竟之前的系统就是在上面进行开发的)<br>需要后端有的时候需要进行定向发送或者是群发,这种需求ws和sse的实现中都有相应的处理.如ChannelGroup和SseBroadcaster,这样在后端获取到一个消息,需要进行路由时就可以从这里面拿相应的channel信息.不过,前提是对各个channel上进行了特定的消息绑定,这样就好区分具体的路由信息.具体路由策略可以在建立时绑定session,后续通过session来路由.<br>三十二、    设计一个幻灯应用，需要列举选择的基础框架、项目的基础框架和代码管理、幻灯数据的存储和读取，部分特效的实现，可以只写思路，后续面聊。<br>本题无标准答案，同学们可以自己研究考虑一下，。<br>三十三、    Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？<br>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的；<br>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>区别：<br>1、    cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。<br>2、    存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br>3、    数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>4、    作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。<br>三十四、    说说你对作用域链的理解<br>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。<br>三十五、    什么是ajax和json，它们的优缺点<br>ajax的全称：Asynchronous Javascript And XML。<br>异步传输+js+xml。实现无刷新状态更新页面和异步提交<br>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>Ajax实现过程：<br>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br>(3)设置响应HTTP请求状态变化的函数<br>(4)发送HTTP请求<br>(5)获取异步调用返回的数据<br>(6)使用JavaScript和DOM实现局部刷新<br>优点：<br>不需要插件支持<br>用户体验极佳<br>提升Web程序性能<br>减轻服务器和宽带的负担<br>缺点：<br>前进后退按钮被破坏<br>搜索引擎的支持不够<br>开发调试工具缺乏<br>JSON（JavaScript Object Notation）和XML一样也是一种简单文本格式。是一种比较流行的标准格式，是数据的载体，相对于XML，JSON更加易读、更便于肉眼检查。在语法的层面上，JSON与其他格式的区别是在于分隔数据的字符，JSON中的分隔符限于单引号、小括号、中括号、大括号、冒号和逗号。<br>优点：<br>   作为一种数据传输格式，JSON 与 XML 很相似，但是它更加灵巧。<br>   JSON不需要从服务器端发送含有特定内容类型的首部信息。<br>缺点：<br>   语法过于严谨<br>   代码不易读<br>   eval 函数存在风险<br>三十六、    Html5有那些新增的表单元素<br>表单控：color，calendar，date，datetime，datetime一local，time，mouth，week，email，url，search，range，tel<br>新的表单元素：datalist，keygen，output<br>三十七、    h1ttp状态码有那些，分别代表什么意思<br>简单版:<br>        100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>        200  OK         正常返回信息<br>        201  Created    请求成功并且服务器创建了新的资源<br>        202  Accepted   服务器已接受请求，但尚未处理<br>        301  Moved Permanently  请求的网页已永久移动到新位置。<br>        302 Found       临时性重定向。<br>        303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。<br>        304  Not Modified 自从上次请求后，请求的网页未修改过。<br>        400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>        401 Unauthorized 请求未授权。<br>        403 Forbidden   禁止访问。<br>        404 Not Found   找不到如何与 URI 相匹配的资源。<br>        500 Internal Server Error  最常见的服务器端错误。<br>        503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。<br>  完整版<br>  1<strong>(信息类)：表示接收到请求并且继续处理<br>    100——客户必须继续发出请求<br>    101——客户要求服务器根据请求转换HTTP协议版本<br>  2</strong>(响应成功)：表示动作被成功接收、理解和接受<br>    200——表明该请求被成功地完成，所请求的资源发送回客户端<br>    201——提示知道新文件的URL<br>    202——接受和处理、但处理未完成<br>    203——返回信息不确定或不完整<br>    204——请求收到，但返回信息为空<br>    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>    206——服务器已经完成了部分用户的GET请求<br>  3<strong>(重定向类)：为了完成指定的动作，必须接受进一步处理<br>    300——请求的资源可在多处得到<br>    301——本网页被永久性转移到另一个URL<br>    302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。<br>    303——建议客户访问其他URL或访问方式<br>    304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用<br>    305——请求的资源必须从服务器指定的地址得到<br>    306——前一版本HTTP中使用的代码，现行版本中不再使用<br>    307——申明请求的资源临时性删除<br>  4</strong>(客户端错误类)：请求包含错误语法或不能正确执行<br>    400——客户端请求有语法错误，不能被服务器所理解<br>    401——请求未经授权，这个状态代码必须和WWW一Authenticate报头域一起使用<br>    HTTP 401.1 一 未授权：登录失败<br>    　　HTTP 401.2 一 未授权：服务器配置问题导致登录失败<br>    　　HTTP 401.3 一 ACL 禁止访问资源<br>    　　HTTP 401.4 一 未授权：授权被筛选器拒绝<br>    HTTP 401.5 一 未授权：ISAPI 或 CGI 授权失败<br>    402——保留有效ChargeTo头响应<br>    403——禁止访问，服务器收到请求，但是拒绝提供服务<br>    HTTP 403.1 禁止访问：禁止可执行访问<br>    　　HTTP 403.2 一 禁止访问：禁止读访问<br>    　　HTTP 403.3 一 禁止访问：禁止写访问<br>    　　HTTP 403.4 一 禁止访问：要求 SSL<br>    　　HTTP 403.5 一 禁止访问：要求 SSL 128<br>    　　HTTP 403.6 一 禁止访问：IP 地址被拒绝<br>    　　HTTP 403.7 一 禁止访问：要求客户证书<br>    　　HTTP 403.8 一 禁止访问：禁止站点访问<br>    　　HTTP 403.9 一 禁止访问：连接的用户过多<br>    　　HTTP 403.10 一 禁止访问：配置无效<br>    　　HTTP 403.11 一 禁止访问：密码更改<br>    　　HTTP 403.12 一 禁止访问：映射器拒绝访问<br>    　　HTTP 403.13 一 禁止访问：客户证书已被吊销<br>    　　HTTP 403.15 一 禁止访问：客户访问许可过多<br>    　　HTTP 403.16 一 禁止访问：客户证书不可信或者无效<br>    HTTP 403.17 一 禁止访问：客户证书已经到期或者尚未生效<br>    404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL<br>    405——用户在Request一Line字段定义的方法不允许<br>    406——根据用户发送的Accept拖，请求资源不可访问<br>    407——类似401，用户必须首先在代理服务器上得到授权<br>    408——客户端没有在用户指定的饿时间内完成请求<br>    409——对当前资源状态，请求不能完成<br>    410——服务器上不再有此资源且无进一步的参考地址<br>    411——服务器拒绝用户定义的Content一Length属性请求<br>    412——一个或多个请求头字段在当前请求中错误<br>    413——请求的资源大于服务器允许的大小<br>    414——请求的资源URL长于服务器允许的长度<br>    415——请求资源不支持请求项目格式<br>    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If一Range请求头字段<br>    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。<br>  5**(服务端错误类)：服务器不能正确执行一个正确的请求<br>    HTTP 500 一 服务器遇到错误，无法完成请求<br>    　　HTTP 500.100 一 内部服务器错误 一 ASP 错误<br>    　　HTTP 500一11 服务器关闭<br>    　　HTTP 500一12 应用程序重新启动<br>    　　HTTP 500一13 一 服务器太忙<br>    　　HTTP 500一14 一 应用程序无效<br>    　　HTTP 500一15 一 不允许请求 global.asa<br>    　　Error 501 一 未实现<br>  HTTP 502 一 网关错误<br>  HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常<br>三十八、    HTTP的请求方法<br>HTTP（Hypertext Transfer Protocol）的八种请求方法：<br>方法    概述<br>❤GET    请求页面的详细信息，并返回实体主体。<br>❤POST    向指定资源提交数据进行数据请求（例如提交表单，或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>PUT    从客户端向服务器传送的数据取代指定的文档内容。<br>DELETE    请服务器删除指定的页面。<br>HEAD    类似与Get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS    允许客户端查看服务器的性能。<br>TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>
<p>三十九、    什么是闭包（closure）为什么要用它<br>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。<br>闭包的特性：<br>1.函数内再嵌套函数<br>2.内部函数可以引用外层的参数和变量<br>3.参数和变量不会被垃圾回收机制回收<br>例如：</p>
<pre><code>//li节点的onclick事件都能正确的弹出当前被点击的li索引
&lt;ul id=&quot;testUL&quot;&gt;
    &lt;li&gt; index = 0&lt;/li&gt;
    &lt;li&gt; index = 1&lt;/li&gt;
    &lt;li&gt; index = 2&lt;/li&gt;
    &lt;li&gt; index = 3&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var nodes = document.getElementsByTagName(&quot;li&quot;);
    for(i = 0;i&lt;nodes.length;i+= 1){
        nodes[i].onclick = (function(i){
                  return function() {
                     console.log(i);
                  } //不用闭包的话，值每次都是4
                })(i);
    }
&lt;/script&gt;
</code></pre><p>执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在<br>使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源<br>因为say667()的内部函数的执行需要依赖say667()中的变量<br>这是对闭包作用的非常直白的描述<br>function say667() {<br>    // Local variable that ends up within closure<br>    var num = 666;<br>    var sayAlert = function() {<br>        alert(num);<br>    }<br>    num++;<br>    return sayAlert;<br>}<br> var sayAlert = say667();<br> sayAlert()//执行结果应该弹出的667</p>
<p>你知道哪些针对jQuery的优化方法<br>基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。<br>频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。</p>
<pre><code>     比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;);
for (var i = size; i &lt; arr.length; i++) {}
     for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
     for (var i = size, length = arr.length; i &lt; length; i++) {}
四十、    用原型链继承的方式写一个类和子类
function Person(name,age){
        this.name=name;
        this.age=age;
    }
    Person.prototype.study=function(){
        return &quot;学习&quot;
    }
    /*var p1 =new Person(&quot;张三&quot;,20);*/
    /*p1.study();*/
    function Student(class_,name,age){
        this.class_=class_;
        this.name=name;
        this.age=age;
    }
    Student.prototype=new Person();
    var s1 =new Student(&quot;二班&quot;,&quot;李大人&quot;,16);
    console.log(s1.name,s1.age,s1.class_,s1.study());
</code></pre><p>四十一、    编写一个方法求一个字符串的字节长度，假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p>
<pre><code>function num(str) {
    var num1 = str.length;
    var num2 = 0;
    for (var i = 0; i &lt; str.length; i++) {
        if (str.charCodeAt(i) &gt;= 10000) {
            num2++;
        }
    }
    console.log(num1 + num2)
}
</code></pre><p>四十二、    简单概括浏览器事件模型，如何获得资源dom节点<br>在各种浏览器中存在三种事件模型:原始事件模型( original event model),DOM2事件模型,IE事件模型.其中原始的事件模型被所有浏览器所支持,而DOM2中所定义的事件模型目前被除了IE以外的所有主流浏览器支持。<br>浏览器事件模型分为三个阶段<br>    1、捕获阶段<br>    2、目标阶段<br>    3、冒泡阶段<br>Dom节点获取方法：<br>1．通过id属性获取 document.getElementById()<br>2．通过name属性获取 document.getElementsByName()<br>3．通过标签名获取 document.getElementsByTagName()<br>4．通过class属性获取 document.getElementsByClassName()<br>5．原生js中的querySelector 和 querySelectorAll方法也同样可以获取到相应的dom节点，相似于jquery，但比jq更快<br>四十三、    写一段ajax提交的js代码</p>
<pre><code>var xhr =xhr();
function xhr(){
        if(window.XMLHttpRequest){
            return  window. XMLHttpRequest();
        }else if(window.ActiveXObject){
            try {
                return  new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
            }catch (e) {
                try {
                    return  new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                }catch (ex) { }
            }
        }
        }
    xhr.open(&quot;get&quot;,&quot;url&quot;,&quot;true&quot;);
    xhr.onreadystatechange=function(){
       if (xhr.readyState==4 &amp;&amp; (xhr.status==200||xhr.status==304)){
           document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;
        }
}
        xhr.send();
}
</code></pre><p>四十四、    判断字符串是否是这样组成的，第一个必须是字母，后面可以是字母和数字、下划线，总长度为5一20（请使用正则表达式）</p>
<pre><code>function if_fit(str){
        var reg=/^[A一Za一z]{1}\w{5,20}/g;
            var result=str.search(reg);
        return result;
    }
</code></pre><p>四十五、    截取字符串abcdefg的efg</p>
<pre><code>var str=&quot;abcdefg&quot;;
console.log(str.slice(4));
</code></pre><p>四十六、    css引入的方式有哪些，link和@import的区别是什么<br>有四种形式:<br>1.链入外部样式表,就是把样式表保存为一个样式表文件,然后在页面中用<link rel="stylesheet" type="text/css" href="*.css">链接这个样式表文件.<br>2.内部样式表,就是把样式表放到页面的<head><meta name="generator" content="Hexo 3.8.0">区里. <style type="text/css"><br>div {height: 600px;}<br></style><br>3.导入外部样式表,用@import,在<head><meta name="generator" content="Hexo 3.8.0">与<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>之间，<style type="text/css"><br>&lt;!一一<br>@import “*.css”<br>一一&gt;<br></style><br>4.内嵌样式,就是在标签内写入style=””,比如:</head></p>
<p><div style="background:#cccccc"></div>设置div背景色为灰色.<br>区别：<br>1）. link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。<br>2）. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>3）. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。<br>4）. link支持使用Javascript控制DOM去改变样式；而@import不支持。<br>四十七、    将字符串helloChina反转输出<br>var str = “helloChina”;<br>方法1：console.log( str.split(“”).reverse().join(“”) )；’);<br>方法2：for (var x = str.length一1; x &gt;=0; x一一) {<br>document.write(str.charAt(x));<br>}<br>方法3：var a=str.split(“”);<br>var rs = new Array;<br>while(a.length){<br>     rs.push(a.pop());<br>}<br>alert(rs.join(“”));</p>
<p>四十八、    为什么无法定义1px左右高度的容器<br>IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：overflow:hidden | zoom:0.08 | line一height:1px<br>四十九、    FireFox中标签的居中问题的解决办法<br><em>{margin：0px auto；}<br>五十、    请写出XHTML和css如何注释<br>XHTML:&lt;!一一 注释内容一一&gt;<br>css:/</em> 注释内容*/<br>五十一、    现在想调节一下父元素的透明度，但是又不影响子元素的透明度，怎么破？<br>方法1：用RGBA<br>方法2：再加一层与父元素同级的div装载子元素 定位到子元素原位置<br>五十二、    简述ECMASCRIPT6的新特性<br>1.增加块作用域<br>2.增加let const<br>3.解构赋值<br>4.函数参数扩展 （函数参数可以使用默认值、不定参数以及拓展参数）<br>5.增加class类的支持<br>6.增加箭头函数<br>7.增加模块和模块加载（ES6中开始支持原生模块化啦）<br>8.math, number, string, array, object增加新的API<br>五十三、    Apply和call方法的异同<br>相同点:两个方法产生的作用是完全一样的，第一个参数都是对象；<br>不同点:<br>call()方法参数将依次传递给借用的方法作参数，即fn.call(thisobj, arg1,arg2,arg3…argn)，有n个参数<br>apply()方法第一个参数是对象，第二个参数是数组fn.apply(thisobj,arg)，此处的arg是一个数组,只有两个参数<br>五十四、    在javascript中什么是伪数组，如何将伪数组转化为标准数组<br>这里把符合以下条件的对象称为伪数组：<br>1，具有length属性<br>2，按索引方式存储数据<br>3，不具有数组的push,pop等方法<br>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，不具有数组的push,pop等方法，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用document.getElementsByTagName, document.childNodes之类的,它们返回的NodeList对象都属于伪数组。<br>可以使用以下函数将伪数组转化为真正的Array对象（兼容问题处理）。</p>
<pre><code>function  makeArray(c) {
    try{
        return Array.prototype.slice.call(c);
    }catch(e){
        var ret = [],i, len = c.length;
        for(i = 0; i &lt; len; i++) {
            ret[i] = (c[i]);
        }
        return ret;
    }
}
</code></pre><p>五十五、    Js和native交互的方法与问题<br>实现JS和Native交互有两种方式:<br>第一种：shouldOverrideUrlLoading(WebView view, String url）<br>通过给WebView加一个事件监听对象（WebViewClient)并重写shouldOverrideUrlLoading(WebView view, String url）方法。当按下某个连接时WebViewClient会调用这个方法，并传递参数view和url<br>第二种：JS和Java互调<br>WebView开启JavaScript脚本执行<br>WebView设置供JavaScript调用的交互接口<br>客户端和网页端编写调用对方的代码<br>JS调用JAVA<br>JS : window.jsInterfaceName.methodName(parameterValues)<br>native: webView.addJavascriptInterface(new JsInteration(), “androidNative”);<br>Java调用JS<br>webView调用js的基本格式为：<br>    webView.loadUrl(“javascript:methodName(parameterValues)”)<br>调用js无参无返回值函数：<br>String call =“javascript:sayHello()；webView.loadUrl(call);<br>调用js有参无返回值函数：<br>String call = “javascript:alertMessage(\”” + “content” + “\”)”;<br>webView.loadUrl(call);<br>调用js有参数有返回值的函数<br>Android在4.4之前并没有提供直接调用js函数并获取值的方法，所以在此之前，常用的思路是 java调用js方法，js方法执行完毕，再次调用java代码将值返回。Android 4.4之后使用evaluateJavascript即可。</p>
<pre><code>private void testEvaluateJavascript(WebView webView) {
  webView.evaluateJavascript(&quot;getGreetings()&quot;, new ValueCallback&lt;String&gt;() {
  @Override
  public void onReceiveValue(String value) {
      Log.i(LOGTAG, &quot;onReceiveValue value=&quot; + value);
  }});
}
</code></pre><p>注:<br>参数类型如果是简单的int或String，可以直接传，对于复杂的数据类型，建议以字符串形式的json返回。<br>evaluateJavascript方法必须在UI线程（主线程）调用，因此onReceiveValue也执行在主线程。<br>当native与js交互时存cookie看到很多人遇到过这样一个问题,cookie存不进去,网上有很多解释方案,但是很多没说到重点上,这里直接贴一下代码:</p>
<pre><code>public static void synCookies(Context context, String url, String version) {
        CookieSyncManager.createInstance(context);
        CookieManager cookieManager = CookieManager.getInstance();
        cookieManager.setAcceptCookie(true);
        cookieManager.removeAllCookie();
        cookieManager.setCookie(url, &quot;sessionKey=&quot;+UserInfoShareprefrence.getInstance(context).getLocalSessionKey())
        cookieManager.setCookie(url, &quot;productVersion=android一epocket一v&quot; + version);
        CookieSyncManager.getInstance().sync();
    }
</code></pre><p>存不进去的很大一部分原因是你的url不对 ,这里的url就是显示的url的域名,这里顺便贴出取域名的方法,给出的是通过正则提取域名<br> /**</p>
<pre><code> * 获得域名
 * @param url
 * @return
</code></pre><p> <em>/<br>public static String getDomain(String url) {<br>        Pattern p = Pattern.compile(“[^//]</em>?\.(com|cn|net|org|biz|info|cc|tv)”, Pattern.CASE_INSENSITIVE);<br>        Matcher matcher = p.matcher(url);<br>        matcher.find();<br>        return matcher.group();<br>    }<br>还有一点就是,如果你想传递多个值给cookie的话,可以多次使用setCookie,不要擅自的自己拼值,因为你拼的字符串中可能存在分号,内部多分号做了特殊处理,截取分号之前的,之后的直接放弃!<br>五十六、    用sass的minix定义一些代码片段，且可传参数<br>/**</p>
<ul>
<li>@module 功能</li>
<li>@description 生成全屏方法</li>
<li>@method fullscreen</li>
<li>@version 1.7.0</li>
<li>@param {Integer} $z一index 指定层叠级别 &lt;1.7.0&gt;</li>
<li>@param {Keywords} $position 指定定位方式，取除<code>static | relative</code>之外的值，默认值：absolute &lt;1.8.5&gt;<br>*/<br>@mixin fullscreen($z一index: null, $position: absolute) {<br> position: $position;<br> z一index: $z一index;<br> top: 0;<br> right: 0;<br> bottom: 0;<br> left: 0;<br>}<br>五十七、    移动端经常出现的兼容问题，谈谈移动端应用或者wap站的一些优化技巧和心得<br>1、    安卓浏览器看背景图片，有些设备会模糊。<br> 因为手机分辨率太小，如果按照分辨率来显示网页，字会非常小，安卓手机devicePixelRatio比较乱，有1.5的，有2的也有3的。想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍），或者指定 background一size:contain;都可以<br>2、    防止手机中网页放大和缩小<br> <meta name="viewport" content="width=device一width, initial一scale=1.0, maximum一scale=1.0,user一scalable=0"><br>3、    apple一mobile一web一app一capable是设置Web应用是否以全屏模式运行。<br> <meta name="apple一mobile一web一app一capable" content="yes">如果content设置为yes，Web应用会以全屏模式运行，反之，则不会。content的默认值是no，表示正常显示;也可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示。<ol start="6">
<li>format一detection 启动或禁用自动识别页面中的电话号码。<br>语法：<meta name="format一detection" content="telephone=no"><br>默认情况下，设备会自动识别任何可能是电话号码的字符串。设置telephone=no可以禁用这项功能。</li>
<li>html5调用安卓或者ios的拨号功能<br>html5提供了自动调用拨号的标签，只要在a标签的href中添加tel:就可以了。<br>如下：<a href="tel:4008106999,1034" target="_blank" rel="noopener">400一810一6999 转 1034</a><br>拨打手机号  如下<a href="tel:15677776767" target="_blank" rel="noopener">点击拨打15677776767</a></li>
<li>上下拉动滚动条时卡顿、慢<br>body {<br>一webkit一overflow一scrolling: touch;<br>overflow一scrolling: touch;<br>}<br>Android3+和iOS5+支持CSS3的新属性为overflow一scrolling</li>
<li>禁止复制、选中文本<br>Element {<br>一webkit一user一select: none;<br>一moz一user一select: none;<br>一khtml一user一select: none;<br>user一select: none;<br>}<br>解决移动设备可选中页面文本(视产品需要而定)</li>
<li>长时间按住页面出现闪退<br>element {<br>一webkit一touch一callout: none;<br>}</li>
<li>iphone及ipad下输入框默认内阴影<br>Element{<br>一webkit一appearance: none;<br>}</li>
<li>ios和android下触摸元素时出现半透明灰色遮罩<br>Element {<br>一webkit一tap一highlight一color:rgba(255,255,255,0)<br>}<br>设置alpha值为0就可以去除半透明灰色遮罩，备注：transparent的属性值在android下无效。详细介绍参照（<a href="http://www.jb51.net/post/phone_web_ysk）" target="_blank" rel="noopener">http://www.jb51.net/post/phone_web_ysk）</a></li>
<li>active兼容处理 即 伪类 :active 失效<br>方法一：body添加ontouchstart<br><body ontouchstart><br>方法二：js给 document 绑定 touchstart 或 touchend 事件<br><style><br>a {<br>color: #000;<br>}<br>a:active {<br>color: #fff;<br>}<br></style><br><a herf="foo">bar</a><script>
document.addEventListener('touchstart',function(){},false);
</script></body></li>
<li>动画定义3D启用硬件加速<br>Element {<br>一webkit一transform:translate3d(0, 0, 0)<br>transform: translate3d(0, 0, 0);<br>}<br>注意：3D变形会消耗更多的内存与功耗</li>
<li>Retina屏的1px边框<br>Element{<br>border一width: thin;<br>}</li>
<li>webkit mask 兼容处理<br>某些低端手机不支持css3 mask，可以选择性的降级处理。<br>比如可以使用js判断来引用不同class：<br>if( ‘WebkitMask’ in document.documentElement.style){<br>alert(‘支持mask’);<br>} else {<br>alert(‘不支持mask’);<br>}</li>
<li>旋转屏幕时，字体大小调整的问题<br>html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {<br>一webkit一text一size一adjust:100%;<br>}</li>
<li>transition闪屏<br>/设置内嵌的元素在 3D 空间如何呈现：保留3D /<br>一webkit一transform一style: preserve一3d;<br>/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /<br>一webkit一backface一visibility:hidden;</li>
<li>圆角bug<br>某些Android手机圆角失效   background一clip: padding一box;</li>
<li>顶部状态栏背景色<br><meta name="apple一mobile一web一app一status一bar一style" content="black"><br>说明：<br>除非你先使用apple一mobile一web一app一capable指定全屏模式，否则这个meta标签不会起任何作用。<br>如果content设置为default，则状态栏正常显示。如果设置为blank，则状态栏会有一个黑色的背景。如果设置为blank一translucent，则状态栏显示为黑色半透明。如果设置为default或blank，则页面显示在状态栏的下方，即状态栏占据上方部分，页面占据下方部分，二者没有遮挡对方或被遮挡。如果设置为blank一translucent，则页面会充满屏幕，其中页面顶部会被状态栏遮盖住（会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px）。默认值是default。</li>
<li>设置缓存<br><meta http一equiv="Cache一Control" content="no一cache"><br>手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no一cache。</li>
<li>桌面图标<br><link rel="apple一touch一icon" href="touch一icon一iphone.png"><br><link rel="apple一touch一icon" sizes="76x76" href="touch一icon一ipad.png"><br><link rel="apple一touch一icon" sizes="120x120" href="touch一icon一iphone一retina.png"><br><link rel="apple一touch一icon" sizes="152x152" href="touch一icon一ipad一retina.png"><br>iOS下针对不同设备定义不同的桌面图标。<br><link rel="apple一touch一icon一precomposed" href="touch一icon一iphone.png"><br>图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px)</li>
<li>启动画面<br><link rel="apple一touch一startup一image" href="start.png"><br>iOS下页面启动加载时显示的画面图片，避免加载时的白屏。<br>可以通过madia来指定不同的大小：<br>&lt;!一一iPhone一一&gt;<br><link href="apple一touch一startup一image一320x460.png" media="(device一width: 320px)" rel="apple一touch一startup一image"><br>&lt;!一一 iPhone Retina 一一&gt;<br><link href="apple一touch一startup一image一640x920.png" media="(device一width: 320px) and (一webkit一device一pixel一ratio: 2)" rel="apple一touch一startup一image"><br>&lt;!一一 iPhone 5 一一&gt;<br><link rel="apple一touch一startup一image" media="(device一width: 320px) and (device一height: 568px) and (一webkit一device一pixel一ratio: 2)" href="apple一touch一startup一image一640x1096.png"><br>&lt;!一一 iPad portrait 一一&gt;<br><link href="apple一touch一startup一image一768x1004.png" media="(device一width: 768px) and (orientation: portrait)" rel="apple一touch一startup一image"><br>&lt;!一一 iPad landscape 一一&gt;<br><link href="apple一touch一startup一image一748x1024.png" media="(device一width: 768px) and (orientation: landscape)" rel="apple一touch一startup一image"><br>&lt;!一一 iPad Retina portrait 一一&gt;<br><link href="apple一touch一startup一image一1536x2008.png" media="(device一width: 1536px) and (orientation: portrait) and (一webkit一device一pixel一ratio: 2)" rel="apple一touch一startup一image"><br>&lt;!一一 iPad Retina landscape 一一&gt;<br>&lt;link href=”apple一touch一startup一image一1496x2048.png”media=”(device一width: 1536px) and (orientation: landscape) and (一webkit一device一pixel一ratio: 2)”rel=”apple一touch一startup一image” /&gt;</li>
<li>浏览器私有及其它meta<br>QQ浏览器私有<br>全屏模式<br><meta name="x5一fullscreen" content="true"><br>强制竖屏<br><meta name="x5一orientation" content="portrait"><br>强制横屏<br><meta name="x5一orientation" content="landscape"><br>应用模式<br><meta name="x5一page一mode" content="app"><br>UC浏览器私有<br>全屏模式<br><meta name="full一screen" content="yes"><br>强制竖屏<br><meta name="screen一orientation" content="portrait"><br>强制横屏<br><meta name="screen一orientation" content="landscape"><br>应用模式<br><meta name="browsermode" content="application"><br>其它(针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓)<br><meta name="HandheldFriendly" content="true"><br>微软的老式浏览器<br><meta name="MobileOptimized" content="320"><br>windows phone 点击无高光<meta name="msapplication一tap一highlight" content="no"></li>
<li>IOS中input键盘事件keyup、keydown、keypress支持不是很好<br>用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻响应keyup事件，只有在通过删除之后才能响应！<br>解决办法：<br>可以用html5的oninput事件去代替keyup<br><input type="text" id="testInput"><br><script type="text/javascript"><br>document.getElementById(‘testInput’).addEventListener(‘input’, function(e){<br>var value = e.target.value;<br>});<br></script><br>然后就达到类似keyup的效果！</li>
<li>h5网站input 设置为type=number的问题<br>一般会产生三个问题，一个问题是maxlength属性不好用了。另外一个是form提交的时候，默认给取整了。三是部分安卓手机出现样式问题。<br>问题一解决，用js如下<br><input type="number" oninput="checkTextLength(this ,10)"><br>function checkTextLength(obj, length) {<br>if(obj.value.length &gt; length)  {<br>  obj.value = obj.value.substr(0, length);<br>}<br>}<br>问题二，是因为form提交默认做了表单验证，step默认是1,要设置step属性，假如保留2位小数，写法如下：<br><input type="number" step="0.01"><br>关于step：input 中type=number，一般会自动生成一个上下箭头，点击上箭头默认增加一个step，点击下箭头默认会减少一个step。number中默认step是1。也就是step=0.01,可以允许输入2位小数，并且点击上下箭头分别增加0.01和减少0.01。<br>假如step和min一起使用，那么数值必须在min和max之间。<br>问题三，去除input默认样式<br>input[type=number] {<br>一moz一appearance:textfield;<br>}<br>input[type=number]::一webkit一inner一spin一button,<br>input[type=number]::一webkit一outer一spin一button {<br>一webkit一appearance: none;<br>margin: 0;<br>}</li>
<li>ios 设置input 按钮样式会被默认样式覆盖<br>解决方式如下：<br>input,<br>textarea {<br>border: 0;<br>一webkit一appearance: none;<br>}<br>设置默认样式为none</li>
<li>IOS键盘字母输入，默认首字母大写<br>解决方案，设置如下属性<input type="text" autocapitalize="off"></li>
<li>select 下拉选择设置右对齐<br>设置如下：<br>select option {<br>direction: rtl;<br>}</li>
<li>通过transform进行skew变形，rotate旋转会造成出现锯齿现象<br>可以设置如下：<br>一webkit一transform: rotate(一4deg) skew(10deg) translateZ(0);<br>transform: rotate(一4deg) skew(10deg) translateZ(0);<br>outline: 1px solid rgba(255,255,255,0)</li>
<li>移动端点击300ms延迟<br>300ms导致用户体验不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。推荐两个js，一个是fastclick，一个是tap.js<br>关于300ms延迟，具体请看：<a href="http://thx.github.io/mobile/300ms一click一delay/" target="_blank" rel="noopener">http://thx.github.io/mobile/300ms一click一delay/</a></li>
<li>移动端点透问题<br>案例如下：<br><div id="haorooms">点头事件测试</div><br><a href="www.jb51.net">www.jb51.net</a><br>div是绝对定位的蒙层,并且z一index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件：<br>$(‘#haorooms’).on(‘tap’,function(){<br>$(‘#haorooms’).hide();<br>});<br>我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。<br>原因：<br>touchstart 早于 touchend 早于click。即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。<br>解决：<br>（1）尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。<br>（2）用fastclick，参考：<a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a><br>（3）用preventDefault阻止a标签的click<br>（4）延迟一定的时间(300ms+)来处理事件 （不推荐）<br>（5）以上一般都能解决，实在不行就换成click事件。<br>下面介绍一下touchend事件，如下：<br>$(“#haorooms”).on(“touchend”, function (event) {<br>event.preventDefault();<br>});</li>
<li>关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)<br>iOS 浏览器横屏时会重置字体大小，设置 text一size一adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text一size一adjust 为 100% 。<br>一webkit一text一size一adjust: 100%;<br>一ms一text一size一adjust: 100%;<br>text一size一adjust: 100%;</li>
<li>关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格可以通过正则去掉this.value = this.value.replace(/\u2006/g, ‘’);</li>
<li>移动端 HTML5 audio autoplay 失效问题<br>这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用JS的触发播放，必须由用户来触发才可以播放。<br>解决方法思路：先通过用户touchstart触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。<br>解决代码：<br>document.addEventListener(‘touchstart’, function () {<br>document.getElementsByTagName(‘audio’)[0].play();<br>document.getElementsByTagName(‘audio’)[0].pause();<br>});</li>
<li>移动端 HTML5 input date 不支持 placeholder 问题<br>复制代码 代码如下:<br><input placeholder="Date" class="textbox一n" type="text" onfocus="(this.type='date')" id="date"><br>有的浏览器可能要点击两遍！</li>
<li>部分机型存在type为search的input，自带close按钮样式修改方法<br>有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为<br>#Search::一webkit一search一cancel一button{<br>display: none;<br>}<br>如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。</li>
<li>唤起select的option展开<br>zepto方式:<br>$(sltElement).trrgger(“mousedown”);<br>原生js方式:<br>function showDropdown(sltElement) {<br>var event;<br>event = document.createEvent(‘MouseEvents’);<br>event.initMouseEvent(‘mousedown’, true, true, window);<br>sltElement.dispatchEvent(event);<br>};<br>五十八、    H5中新增的单位rem是什么意思，和em的关系，以及rem在自适应布局中的应用方法<br>Rem为单位：<br>rem是相对于根元素<html>的“font一size”为基准。比如说我们给html设置font一size为100px，<br>那么我们要给html中的p标签设置16px的字体，font一size设置.16rem就可以，在这里16px=.16rem。<br>Em为单位：<br>这种技术需要一个参考点，一般都是以<body>的“font一size”为基准。比如说我们使用“1em”等于“10px”来改变默认值“1em=16px”，这样一来，我们设置字体大小相当于“14px”时，只需要将其值设置为“1.4em”。<br>这个单位与em有什么区别呢？<br>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。<br>五十九、    如何实现浏览器内多个标签页之间的通信？<br>通过WebSocket或SharedWorker把客户端和服务器端建立socket连接，从而实现通信；也可以调用localstorge、cookies等本地存储方法。<br>六十、    假设现在页面里有一个id是con的div，现在需要编写js代码，在页面加载完成后 将div的高度设置成100px，宽度设置成60px，并设置成灰色的1px的边框，背景设置成浅黄色。<br>window.onload=function(){<br>var oDiv=document.getElementById(“con”);<br>oDiv.style.height=”100px”;<br>oDiv.style.width=”60px”;<br>oDiv.style.width=”1px solid gray”;<br>oDiv.style.backgroundColor=”yellow”;<br>}<br>六十一、    对新技术有那些了解，常去的网站有那些<br>node.js、angular.js、vue.js，reactjs，react-native，微信小程序<br>掘金、简书、github、csdn，知乎等<br>六十二、    用程序找出数组中出现次数超过一半的数字<br>思路：<br>1、 一个数字在数组中出现次数超过了一半，则排序后，位于数组中间的数字一定就是该出现次数超过了长度一半的数字（可以用反证法证明），也即是说，这个数字就是统计学上的中位数。最容易想到的办法是用快速排序对数组排序号后，直接取出中间的那个数字，这样的时间复杂度为O(nlogn)，空间复杂度为O(1)。<br>2 、事实上可以不用对数组进行排序，或者说仅部分排序，受快速排序的partition函数的启发，我们可以利用反复调用partition函数来求的该数字。我们现在数组中随机选取一个数字，而后通过Partition函数返回该数字在数组中的索引index，如果index刚好等于n/2，则这个数字便是数组的中位数，也即是要求的数，如果index大于n/2，则中位数肯定在index的左边，在左边继续寻找即可，反之在右边寻找。这样可以只在index的一边寻找，而不用两边都排序，减少了一半排序时间。这种情况的平均时间复杂度大致为：T(n) = n+n/2+n/4+n/8+….+1，很明显当n很大时，T(n)趋近于2n，也就是说平均情况下时间复杂度为O(n),但是这种情况下，最坏的时间复杂度依然为O(n<em>n)，最坏情况下，index总是位于数组的最左或最右边，这样时间复杂度为T(n) = n+n一1+n一2+n一3+….+1 = n(n一1)/2，显然，时间复杂度为O(n</em>n)，空间复杂度为O(1)。<br>六十三、    请设计一套方案，用于确保页面中js加载完全，对于优化某网页的加载速度，有什么独到见解<br>js方法：<pre><code>&lt;script type=&quot;text/javascript&quot;&gt; 
window.onload=function(){ 
var userName=&quot;xiaoming&quot;; 
alert(userName); 
} 
&lt;/script&gt;
jquery方法：
&lt;script type=&quot;text/javascript&quot;&gt; 
$(document).ready(function(){ 
var userName=&quot;xiaoming&quot;; 
alert(userName); 
}); 
&lt;/script&gt; 
</code></pre></body></html></li>
</ol>
</li>
</ul>
<p>或者简写：</p>
<pre><code>$(function(){ 
var userName=&quot;xiaoming&quot;; 
alert(userName); 
});
</code></pre><p>如何确定一个js是否加载完全或者页面中的所有js加载完全，具体办法如下：</p>
<pre><code>function loadScript（ url, callback） {
    var script = document.createElement(&quot;script&quot;);
    script.type = &quot;text/javascript&quot;;
    if (script.readyState) {
        script.onreadystatechange = function() {
            if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;) {
                script.onreadystatechange = null;
                callback();
            }
        }
    } else {
        script.onload = function() {
            callback();
        }
    }
    script.src = url;
    document.getElementsByName(&quot;head&quot;)[0].appendChild(script);
}
</code></pre><p>如何让脚本的执行顺序按照你设定的顺序执行，使用嵌套的方式：</p>
<pre><code>loadScript(&quot;file1.js&quot;, function() {
    loadScript(&quot;file2.js&quot;, function() {
        loadScript(&quot;file3.js&quot;, function() {
            alert(&quot;All files are loaded&quot;);
        });
    });
});
</code></pre><p>网页加载速度优化：<br>1、减少请求<br>最大的性能漏洞就是一个页面需要发起几十个网络请求来获取诸如样式表、脚本或者图片这样的资源，这个在相对低带宽和高延迟的移动设备连接上来说影响更严重。<br>CDNs（内容分发网络）把资源放在离用户地理位置更近的地方对解决这个问题能起到很大作用，但是比起获取请求，大量的请求对页面加载时间的影响更为严重，而且最近的发现表明，CDNs对移动端用户的性能影响越来越低。<br>2、整合资源<br>对开发者来说，将Javascript代码和CSS样式放到公共的文件中供多个页面共享是一种标准的优化方法，这个方法能很简单的维护代码，并且提高客户端缓存的使用效率。<br>在Javascript文件中，要确保在一个页面中相同的脚本不会被加载多次，当大团队或者多个团队合作开发的时候，这种冗余的脚本就很容易出现，你可能会对它的发生频率并不低感到非常吃惊。<br>Sprites是css中处理图片的一项技术，Sprites就是将多张图片整合到一个线性的网状的大图片中，页面就可以将这个大图片一次性获取回来并且做为css的背景图，然后使用css的背景定位属性展示页面需要的图片部分，这种技术将多个请求整合成一个，能显著地改善性能。<br>平稳地改进但是需要对资源有控制权限，根据开发者的网站不同权限，一些资源并不需要被整合起来（例如，一些由CMS生成的资源），还有，对于一些外部域引用的资源，强行整合可能会导致问题，马海祥提醒大家需要注意的是，整合资源对手机浏览器来说是一把双刃剑，整合资源确实会在首次访问减少请求，但是大的资源文件可能会导致缓存失效，所以，需要小心地使用各种技术整合资源，以达到优化本地存储的目的。<br>3、使用浏览器缓存和本地缓存<br>现在所有的浏览器都会使用本地资源去缓存住那些被Cache一Control或者Expires头标记的资源，这些头能标记资源需要缓存的时间，另外，ETag（实体标签）和Last一Modified头来标识当资源过期后是否需要重新请求，浏览器为了减少不必要的服务器请求，尽可能地从本地缓存中获取资源，并且将那些已经过期的、或者当缓存空间减小的时候将那些很久不用的资源进行清理，浏览器缓存通常包括图片，CSS，Javascript代码，这些缓存能合理地提高网站的性能（比如为了支持后退和前进的按钮，使用一个单独的缓存来保存整个渲染的页面）。<br>移动浏览器缓存，通常是比桌面PC小的多，这就导致了缓存的数据会很经常被清理，HTML5的缓存基于浏览器缓存提供了一个很好的替换方案，Javascript的localStorage已经在所有主流的桌面和移动端浏览器上都实现了，使用脚本代码能简便地支持HTML5的localStorage操作，可以读写键值数据，每个域名大概有5MB的容量，虽然不同的移动浏览器上读写速度相差很大，但是localStorage大容量的缓存使得它很适合作为客户端的缓存，从localStorage获取资源明显快于从服务器上获取资源，而且在大多数移动设备上也比依靠缓存头或者浏览器的本地缓存更灵活可靠，这是移动浏览器比桌面PC更有优势的一个地方，在桌面PC上，本地缓存仍然优先使用标准的浏览器缓存，导致桌面PC本地缓存的性能落后于移动浏览器。<br>在此，马海祥要提醒各位一下：虽然localStorage的机制易于实现，但是它的一些控制机制却是非常复杂的，你需要考虑到缓存带给你的所有问题，比如缓存失效（什么时候需要删除缓存？），缓存丢失（当你希望数据在缓存中的时候它并不在怎么办？），还有当缓存满的时候你怎么办？<br>4、首次使用的时候在HTML中嵌入资源<br>HTML的标准是使用链接来加载外部资源，这使得更容易在服务器上（或者在CDN上）操作更新这些资源，而不是在每个页面上修改更新这些资源，根据上文讨论的，这种模式也使得浏览器能从本地缓存而不是服务器上获取资源。<br>但是对还没有缓存到浏览器localStorage的资源来说，这种模式对网站的性能有负面的影响，一般来说，一个页面需要几十个单独的请求来获取资源从而渲染页面。<br>所以说，从性能的角度来说，如果一个资源没有很高的被缓存的几率的话，最好把它嵌入到页面的HTML中（叫inlining），而不是使用链接外部，脚本和样式是支持内嵌到HTML中的，但是图片和其他的二进制资源其实也是可以通过内嵌包含base64编码的文本来嵌入到HTML中的。<br>内嵌的缺点是页面的大小会变得非常大，所以对于Web应用来说，关键的是能够跟踪分析这个资源什么时候需要从服务端获取，什么时候已经缓存到客户端了。<br>另外，在第一次请求资源后必须能够使用代码在客户端缓存资源，因此，在移动设备上，使用HTML5 localStorage能很好地做到内嵌。<br>由于不知道用户是否已经访问过这个页面了，所以需要网站有机制能生成不同版本的页面。<br>5、使用HTML5服务端发送事件<br>Web应用已经使用了各种从服务器上轮询资源的方法来持续地更新页面，HTML5的EventSource对象和Server一Sent事件能通过浏览器端的JavaScript代码打开一个服务端连接客户端的单向通道，服务端可以使用这个写通道来发送数据，这样能节省了HTTP创建多个轮询请求的消耗。<br>这种方式比HTML的WebSocket更高效，WebSocket的使用场景是，当有许多客户端和服务端的交互的时候（比如消息或者游戏），在全双工连接上建立一个双向通道。<br>这个技术是基于具体的技术实现的，如果你的网站当前是使用其他的Ajax或者Comet技术来轮询的，转变成Server一Sent事件需要重构网站的Javascript代码。<br>6、消除重定向<br>当用户在一个移动设备上访问桌面PC网站的时候，Web网站应用通常读取HTTP的user一agent头来判断这个用户是否是来自移动设备的，然后应用会发送带有空HTTP body和重定向HTTP地址头的HTTP 301（或者302）请求，把用户重定向到网站的移动版本上去，但是这个额外的客户端和服务端的交互通常在移动网络上会消耗几百毫秒，因此，在原先的请求上传递移动的web页会比传递一个重定向的信息并让客户端再请求移动页面更快。<br>对于那些想要在移动设备上看桌面PC网站的用户来说，你可以在移动web页面上提供一个链接入口，这样也能同时表示你的网站是并不提倡这种行为的。<br>虽然这个技术在理论上是简单的，但是实际上并不易于实施，由于有些m.sites是宿主在其他地方的，所以许多网站会选择重定向到一个不同的服务器上，有的网站则是会在重定向请求的时候种植上Cookie告诉Web应用这个用户是在使用移动设备，这种方法可能对web应用来说更容易控制。<br>7、减少资源负载<br>关于移动端页面的大小问题，渲染小页面更快，获取小资源也更快，减小每个请求的大小通常不如减少页面请求个数那么显著地提高性能。<br>但是有些技术在性能方面，特别是在需要对带宽和处理器性能精打细算的移动设备环境下，仍然是能带来很大利益的。<br>8、压缩文本和图像<br>诸如gzip这样的压缩技术，依靠增加服务端压缩和浏览器解压的步骤，来减少资源的负载，但是，一般来说，这些操作都是被高度优化过了，而且测试表明，压缩对网站还是起到优化性能的作用的，那些基于文本的响应，包括HTML，XML，JSON（Javascript Object Notation），Javascript，和CSS可以减少大约70%的大小。<br>浏览器在Accept一Encoding请求头中申明它的解压缩技术，并且当它们接收到服务端返回的Content一Encoding响应头标示的时候，就会按照这个响应头自动做解压操作。<br>马海祥觉得这种方法的优点就是易于实现，如果设置正确的话，现在所有的Web服务器都支持压缩响应，但是，也有一些桌面PC的安全工具会将请求头中的Accept一Encoding头去掉，这样即使浏览器支持解压缩，用户也无法获取到压缩后的响应。<br>9、代码简化<br>简化通常是使用在脚本和样式文件中，删除一些不必要的字符，比如空格，换行符，或者注释等，不需要暴露给外部的命名就可以被缩短为一个或者两个字符，比如变量名，合适的简化资源通常在客户端不需要做任何其他的处理，并且平均减少20%的资源大小，内嵌在HTML中的脚本和样式文件也是可以精简的，有很多很好的库来做精简化的操作，这些库一般也同时会提供合并多个文件这样减少请求数的服务（具体可查看马海祥博客《手机网站制作的常用方法及优化技巧》的相关介绍）。<br>简化带来的好处并不局限于减少带宽和延迟，对于那些移动设备上缓存无法保存的过大资源来说，也是很有改善的，Gzip在这个方面并没有任何帮助，因为资源是在被解压后才被缓存起来的。<br>Google的Closure Compiler已经难以置信地完成了理解和简化Javascript的工作，但是CSS的简化则没有那么容易，因为对不同浏览器来说有不同的CSS技术能迷惑CSS简化工具，然后让CSS简化后无法正常工作，马海祥提醒大家必须要注意的是，已经有这样的案例了，即使只是删除了不必要的字符，简化工作也有可能破坏页面，所以当你应用简化技术之后，请做一下完整的功能测试工作。<br>10、调整图片大小<br>图片通常是占用了Web页面加载的大部分网络资源，也占用了页面缓存的主要空间，小屏幕的移动设备提供了通过调整图片大小来加速传输和渲染图片资源的机会，如果用户只是在小的移动浏览器窗口中看图片的话，高分辨率的图片就会浪费带宽、处理时间和缓存空间。<br>为了加速页面渲染速度和减少带宽及内存消耗，可以动态地调整图片大小或者将图片替换为移动设备专用的更小的版本，不要依靠浏览器来将高分辨率的图片转换成小尺寸的图片，这样会浪费带宽。<br>另外一个方法是先尽快加载一个低分辨率的图片来渲染页面，在onload或者用户已经开始和页面交互以后将这些低分辨率的图片替换成为高分辨率的图片。<br>特别应用在高度动态化的网站是有优势的。<br>11、使用HTML5和CSS 3.0来简化页面<br>HTML5包括了一些新的结构元素，例如header，nav，article和footer，使用这些语义化的元素比传统的使用div和span标签能使得页面更简单和更容易解析，一个简单的页面更小加载更快，并且简单的DOM（Document Object Model）代表着更快的JavaScript执行效率，新的标签能很快地应用在包括移动端的新浏览器版本上，并且HTML5设计让那些不支持它的浏览器能平稳过渡使用新标签。<br>HTML5的一些表单元素提供了许多新属性来完成原本需要javascript来完成的功能，例如，新的placeholder属性用于显示在用户输入进入输入框之前显示的介绍性文字，autofocus属性用于标示哪个输入框应当被自动定位。<br>也有一些新的输入框元素能不用依靠Javascript就可以完成一些通用的需求，这些新的输入框类型包括像e一mail，URL，数字，范围，日期和时间这样需要复杂的用户交互和输入验证的元素，在移动浏览器上，当需要输入文本的时候，弹出的键盘通常是由特定的输入框类型来做选择的，不支持指定的输入类型的浏览器就会只显示一个文本框。<br>另外，只要浏览器支持内建的层次，圆角，阴影，动画，过渡和其他的图片效果，CSS 3.0就能帮助你创建轻便简易的页面了，而这些图片效果原先是需要加载图片才能完成的，这样，这些新特性就能加速页面渲染了。<br>人工地做这些改动是非常复杂和耗时的，如果你使用CMS，它可以帮你生成许多你不需要控制的HTML和CSS（具体可查看马海祥博客《制作移动端手机网站过程中的SEO优化方法技巧》的相关介绍）。<br>12、延迟渲染”BELOW一THE一FOLD”内容<br>可以确定的是如果我们将不可见区域的内容延迟加载，那么页面就会更快地展现在用户面前，这个区域叫做“below the fold”，为了减少页面加载后需要重新访问的内容，可以将图片替换为正确的高宽所标记的<img>标签。<br>一些好的Javascript库可以用来处理这些below一the一fold 延迟加载的图像。<br>13、延迟读取和执行的脚本<br>在一些移动设备上，解析Javascript代码的速度能达到100毫秒每千字节，许多脚本的库直到页面被渲染以后都是不需要的加载的，下载和解析这些脚本可以很安全地被推迟到onload事件之后来做。<br>例如，一些需要用户交互的行为，比如托和拽，都不大可能在用户看到页面之前被调用，相同的逻辑也可以应用在脚本执行上面，尽量将脚本的执行延迟到onload事件之后，而不是在初始化页面中重要的可被用户看到的内容的时候执行。<br>这些延迟的脚本可能是你自己写的，更重要的是，也有可能是第三方的，对广告、社交媒体部件、或者分析的差劲的脚本优化会导致阻塞页面的渲染，会增加珍贵的加载时间，当然，你需要小心地评估诸如jquery这样为移动网站设计的大型脚本框架，特别当你仅仅只是使用这些框架中的一些对象的时候更要小心评估。<br>许多第三方的框架现在提供延迟加载的异步版本的API，开发者只需要将原先的逻辑转化到这个异步版本，一些JavaScript要做延迟加载会有些复杂，因为在onload之后执行这些脚本需要注意很多注意事项（例如，你有个脚本需要绑定到onload事件上，你需要做什么？如果你将脚本延迟到onload事件之后，就一定就会失去很多执行的时机）。<br>14、使用Ajax来增强进程<br>Ajax（Asynchronous JavaScript and XML）是一项使用XHR（XMLHttpRequest）对象来从Web服务器上获取数据的技术，它并不需要更新正在运行的页面，Ajax能更新页面上的某个部分而不需要重新构建整个页面，它通常用来提交用户的交互相应，但是也可以用来先加载页面的框架部分，然后当用户准备好浏览网页的时候再填充详细的内容。<br>尽管是这个名字，但是XMLHttpRequest并不强制要求你只能使用XML，你可以通过调用overrideMineType方法来制定“application/json”类型来使用json替换XML，使用JSON.parse会比使用原生的eval()函数快了几乎两倍，并且更为安全。<br>同时，切记Ajax的返回响应也会得益于那些应用在普通的返回响应的优化技术上面，确保对你的Ajax返回响应使用了缓存头，简化，gzip压缩，资源合并等技术。<br>由于这个技术是根据具体应用不同而不同的，所以很难量化，或许由于跨域问题，你需要使用XHR2，这个技术能使用外部域的资源，从而能进行跨域的XHR请求。<br>15、根据网络状况进行适配处理<br>由于使用更多带宽会使用更多移动网络的费用，所以只有能检测网络的类型才能使用针对特定网络的优化技术。<br>例如，预加载未来使用到的请求是非常聪明的做法，但是如果用户的带宽很稀有，并且加载的有些资源是永远不会用到的话，这个技术就是不合理的了。<br>在Android 2.2+，navigator.connection.type属性的返回值能让你区分Wifi和2G/3G/4G网络，在Blackberry上，blackberry.network也能提供相似的信息，另外，服务端通过检测请求中的User一Agent头或者其他的嵌入到请求中的信息能让你的应用检测到网络状况。<br>检测网络信息的API最近已经有所变化了，接口现在不是直接定义Wi一Fi，3G等网络状况，而是给出了带宽信息和诸如“非常慢，慢，快和非常快”这样的建议，有个属性能给出估计的MB/s值和一个“meterd”的Boolean值来表示它的可信度，但是对浏览器来说，很难根据这个来判断环境，判断当前网络环境然后适配仍然是一种最好的方法（具体可查看马海祥博客《百度移动搜索开放适配服务的3种方法》的相关介绍），但是这种方法正在被考虑被替换。<br>16、对多线程来说尽量使用HTML5的WEB WORKER特性<br>HTML5中的Web Worker是使用多个线程并发执行Javascript程序，另外，这种特别的多线程实现能减少困惑开发者多年的，在其他平台上遇到的问题，例如，当一个线程需要改变一个正在被其他线程使用的资源该如何处理，在Web Worker中，子线程不能修改主用户界面（UI）线程使用的资源。<br>对提高移动站点的性能来说，Web Worker中的代码很适合用来预处理用户完成进一步操作所需要的资源的，特别是在用户的带宽资源不紧缺的情况下，在低处理器性能的移动设备上，过多的预加载可能会干扰当前页面的UI响应，使用多线程代码，让Web Worker对象（并且尽可能使用localStorage来缓存数据）在另外一个线程中操作预加载资源，这样就能不影响当前的UI表现了。<br>要特别说明的是，Web Worker只在Android 2.0以上的版本实现，而且iphone上的ios5之前的版本也不支持，在桌面PC上，总是落后的IE只在IE 10才支持Web Worker。<br>虽然这项技术并不是非常难实现，但是对Web Workers来说，有一些限制需要强制遵守，Web Workers不能进入到页面的DOM，也不能改变页面上的任何东西，Web Worker很适合那种需要后台计算和处理的工作。<br>17、将CLICK事件替换成TOUCH事件<br>在触摸屏设备上，当一个用户触碰屏幕的时候，onclick事件并没有立即触发，设备会使用大约半秒（大多数设备差不多都是300毫秒）来让用户确定是手势操作还是点击操作，这个延迟会很明显地影响用户期望的响应性能，要使用touchend事件来替换才能解决，当用户触碰屏幕的时候，这个事件会立即触发。<br>为了要确保不会产生用户不期望的行为，你应该也要使用touchstart和touchmove事件，例如，除非同时有个touchstart事件在button上，否则不要判断touchend事件在button上就意味着点击行为，因为用户有可能从其他地方触碰开始，然后拖拽到button上触碰结束的，你也可以在touchstart事件之后使用touchmove事件来避免将touchend事件误判为点击，当然前提是需要假设拖拽的手势并不是预期产生点击行为。<br>另外，你也需要去处理onclick事件来让浏览器改变button的外观从而标识为已点击的状态，同时你也需要处理那些不支持touch事件的浏览器，为了避免代码在touchend和onclick代码中重复执行，你需要在确保用户触碰事件已经在touchend执行了之后，在click事件中调用preventDefault和stopPropagation方法。<br>这种技术需要更多工作才能在一个页面中增加和维护链接，touch事件的代码必须考虑其他手势，因为替换click的还有可能是缩放或者敲击动作。<br>18、支持SPDY协议<br>应用层HTTP和HTTPS协议导致的一些性能瓶颈，使得不论是桌面还是移动端的网站都非常难受，在2009年，谷歌开始研发一种叫做SPDY（谐意是“speedy”）的协议来替换已有的协议，这种协议宣称能突破这些限制，这个协议的目标是让多种浏览器和多种Web服务都能支持，所以这个协议是开源的，但是初步地，只有Google的Chrome浏览器（在版本10及之后的）和google的站点支持，一旦一个Web服务支持SPDY，那么它上面的所有站点都可以和支持这个协议的浏览器使用SPDY进行交互，将SPDY应用在25个top100的Internet网站上，Google收集到的数据是网站的速度会改善27%到60%不等。<br>SPDY自动使用gzip压缩所有内容，和HTTP不同的是，它连header的数据也使用gzip压缩，SPDY使用多线程技术让多个请求流或者响应流能共用一个TCP连接，另外SPDY允许请求设置优先级，比如，页面中心的视频会比边框的广告拥有更高的优先级。<br>或许SPDY中最变革性的发明就是流是双向的，并且可以由客户端或者服务端发起，这样能使得信息能推送到客户端，而不用由客户端发起第一次请求，例如，当一个用户第一次浏览一个站点，还没有任何站点的缓存，这个时候服务端就可以在响应中推送所有的请求资源，而不用等候每个资源被再次独立请求了，作为替换协议，服务端可以发送暗示给客户端，提示页面需要哪些资源，同时也允许由客户端来初始化请求。即使是使用后一种这样的方式也比让客户端解析页面然后自己发现有哪些资源需要被请求来得快。<br>虽然SPDY并没有对移动端有什么特别的设置，但是移动端有限的带宽就使得如果支持SPDY的话，SPDY在减少移动网站的延迟是非常有用的。<br>依据网站和服务的环境来进行平稳操作或进一步考虑，Google有一个SPDY模块支持Apache2.2 – mod_spdy – 这个模块是免费的；但是mod_spy有线程上的问题，并且和mod_php协作并不是很好，所以要求你使用这个技术的时候要确保你的网站的正常运行。</p>
	
	</div>
	
	<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

	<!-- relate post, comment...-->
	<div class="investment-container">
		<div class="investment-header">
			<div class="investment-title-1">
				<div class="on">相关文章</div>
				<div>评论</div>
			</div>
			<div class="investment-title-2">	            
				
	<span>
		<a href="javascript: window.scrollTo(0, 0);">返回顶部</a>
		
			<a href="/2019/03/27/面试宝典二/" title="面试宝典二" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2019/03/27/变量-前端面试题/" title="变量-前端面试题" rel="next">
				下一篇&raquo;
			</a>
			
	</span>
      		
			</div>	
		</div>
		
		<div class="investment-content">
			<div class="investment-content-list">
				

<div class="relate-post">
	<ul>
		
				<li>
					<div>
						<a href="/2019/03/27/面试宝典二/" title="面试宝典二">
							面试宝典二
						</a>
						<p>
							六十四、    请实现鼠标点击任意标签，alert该标签的名称（注意兼容性）
function elementName(evt){
        evt = evt|| window.event;
        var selec...
						</p>
					</div>

					<a href="/2019/03/27/面试宝典二/" title="面试宝典二">				
						<img src="/img/cart_cover.jpg" class="relateImg" alt="面试宝典二">
					</a>
				</li>											
		
		
				<li>
					<div>
						<a href="/2019/03/27/变量-前端面试题/" title="变量-前端面试题">
							变量-前端面试题
						</a>
						<p>
							
知识点 var let  变量提升 暂时性死区

console.log(foo);
var foo = &quot;test&quot;;
写出上边程序的输出结果

						</p>
					</div>

					<a href="/2019/03/27/变量-前端面试题/" title="变量-前端面试题">				
						<img src="/img/cart_cover.jpg" class="relateImg" alt="变量-前端面试题">
					</a>
				</li>											
		
		
				<li>
					<div>
						<a href="/2019/03/27/this-前端面试题/" title="this-前端面试题">
							this-前端面试题
						</a>
						<p>
							


						</p>
					</div>

					<a href="/2019/03/27/this-前端面试题/" title="this-前端面试题">				
						<img src="/img/cart_cover.jpg" class="relateImg" alt="this-前端面试题">
					</a>
				</li>											
		
		
	</ul>
</div>	
			</div>
			<div class="investment-content-list">
				<div class="layout-comment">

	

		

			<!-- comment gitalk -->
			<!-- show gitalk comment -->
<div id="gitalk-container"></div>

<!-- gitalk`s css & js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<link rel="stylesheet" href="/css/comment.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="text/javascript">
	//Thanks O-R
	//https://github.com/gitalk/gitalk/issues/102#issuecomment-382970552
	//去除尾部匹配正则数组的字符串  
	//Remove redundant characters
	String.prototype.trimEnd = function(regStr) {
		var result = this;
		if(regStr == undefined || regStr == null || regStr == "") {
			return result;
		}
		var array = regStr.split(',');

		if(array.length > 0) {

			var c = array.shift();
			var str = this;
			var i = str.length;
			var rg = new RegExp(c);
			var matchArr = str.match(rg);

			if(matchArr != undefined && matchArr != null && matchArr.length > 0) {
				var matchStr = matchArr[0].replace(/\\/g, "\\\\").replace(/\*/g, "\\*")
					.replace(/\+/g, "\\+").replace(/\|/g, "\\|")
					.replace(/\{/g, "\\{").replace(/\}/g, "\\}")
					.replace(/\(/g, "\\(").replace(/\)/g, "\\)")
					.replace(/\^/g, "\\^").replace(/\$/g, "\\$")
					.replace(/\[/g, "\\[").replace(/\]/g, "\\]")
					.replace(/\?/g, "\\?").replace(/\,/g, "\\,")
					.replace(/\./g, "\\.").replace(/\&/g, "\\&");
				matchStr = matchStr + '$';
				result = str.replace(new RegExp(matchStr), "");
			}

			if(array.length > 0) {
				return result.trimEnd(array.join())
			} else {
				return result;
			}
		}
	};

	//Create gitalk
	var gitalk = new Gitalk({
		clientID: 'f015112af3b8fcf72123',
		clientSecret: '1328483e7a49433c4d3250b6508b33b86b9ef91a',
		//id: window.location.pathname,
		//id: decodeURI(window.location.pathname),
		//id: (window.location.pathname).split("/").pop().substring(0, 49),
		id: decodeURI( md5( location.href.trimEnd('#.*$,\\?.*$,index.html$') ) ),
		repo: 'ccOnTheWay-gitalk',
		owner: 'ccOnTheWay',
		admin: 'ccOnTheWay',
		distractionFreeMode: 'true',
	})
	gitalk.render('gitalk-container');
</script>

		
		
	

</div>
			</div>
		</div>	
	</div>
</div>



	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->



	<script>
		var appid = 'dX--',
            appkey = 'dx--';	  
        AnnieLeancloud(appid, appkey);         
	</script>
    


 

<!-- show math formula -->




<!-- TODO: There seems to be a bug when you close the post gallery! -->
<link rel="stylesheet" href="/plugin/lightgallery/css/lightgallery.css">
<script src="/plugin/lightgallery/js/jquery-1.11.0.min.js"></script>
<script src="/plugin/lightgallery/js/lightgallery-all.min.js"></script>

<script type="text/javascript">
	var postTitle = $('.article-title a').text() ? $('.article-title a').text() : "No post title!";
	$('.article-content img').each(function() {
		var imgPath = $(this).attr('src'),
			imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		$(this).wrap('<div class="img-responsive" data-src="' + imgPath + '" data-responsive="' + imgPath + '" data-sub-html="<p>图片 ' + imgTitle + '</p><h4>文章' + postTitle + '</h4>"></div>');
	});

	$('.article-content').lightGallery({
		mode: 'lg-slide',
		selector: '.img-responsive',
		share: false,
		zoom: false,
		download: false
	});
	//TODO：支持video
</script>

<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->
	
		</main>
		
		<!--footer-->
		<footer>
	<div class="social">
		<ul>
	
		
			<li>
				<a href="https://github.com/ccOnTheWay/wiki" title="Github" target="_blank">
					<i class="fa fa-github"></i>
				</a>
			</li>
		
		
		
			<li>
				<a href="mailto:fengxicai@fengxicai.cn" title="Email" target="_blank">
					<i class="fa fa-envelope-o"></i>
				</a>
			</li>
		

		
		
	 
</ul>
	</div>
		
	<div class="copyright">
		<p>
			 
				&copy;2019, content by FXC. All Rights Reserved.
			
			
			

	<!-- busuanzi -->
	<!-- busuanzi -->

		
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

		<span id="busuanzi_container_page_pv">
	  		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
		</span>

	




		</p>
		<!-- <p>
			<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay. 					
		</p> -->
	</div>		
</footer>
		
    <!-- set '1' to show motto in all pages! -->

	<script src="/js/motto.js"></script>
	<script type="text/javascript">
		$(".motto").html( getMingYanContent() );
	</script>	




    <!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup">
	<div class="local-search-container">
		<span class="popup-btn-close">
      ESC
   </span>
		<div class="local-search-header">
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			

   
	<div id="topN"></div>
	
    <script>
        var appid = 'dX--',
            appkey = 'dx--',
            limitCount = 10;
        if( $('#topN').length ){
            AV.initialize(appid, appkey);
            var Counter = AV.Object.extend("Counter");  
            topNPost(Counter, limitCount);
        }
    </script>
   

		</div>
	</div>
</div>

<script src="/js/ziploader.js"></script>
<script src="/js/search.js"></script>

<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>



    <script src="/js/love.js"></script>


<!--back to top-->

    
	<div id="totop">
  		<a href="javascript:;" name="TOTOP" class="fa fa-arrow-up"></a>
	</div>
	<div id="tobuttom">
		<a href="javascript:;" name="TOBUTTOM" class="fa fa-arrow-down"></a>
	</div>
 


 

<script src="/js/vibrant.js"></script>
<script src="/js/chinese.js"></script>
<script src="/js/main.js"></script>
	</body>
	</html>
