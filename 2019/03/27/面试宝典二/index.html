<!--
	作者：Sariay
	时间：2018-09-25
	描述：There may be a bug, but don't worry, QiLing(器灵) says that it can work normally!
-->

	<!DOCTYPE html>
	<html class="scrollbar">
		

<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      面试宝典二 | 前端进阶之路
    
  </title>
  <meta name="author" content="FXC">
  <meta name="keywords" content>
  <meta name="description" content>
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

    <!-- jquery -->
	<script src="/js/jquery-2.1.1.min.js"></script>

  <!-- leancloud -->
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script src="/js/leancloud.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="transition">
					<div class="three-bounce1"></div>
					<div class="three-bounce2"></div>
					<div class="three-bounce3"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground" data-img-mode="normal" data-normal-src="/img/wolf.jpg" data-random-max="110" data-random-src="https://sariay.github.io/Random-img/">
	<div class="mask">
		<div class="h-header">
			<div id="logo-S">
				
					<a href="/">
						<img src="/img/logo.png" alt="Logo">
					</a>
				
			</div>
			<!-- Navigation in header(id="navigation-S") -->
			<div id="navigation-S">
				<ul>
					
						<li class="menu-home">
							<a href="/" class="menu-item-home">主页</a>
						</li>
					
						<li class="menu-archive">
							<a href="/archives" class="menu-item-archive">归档</a>
						</li>
					
						<li class="menu-categories">
							<a href="/categories" class="menu-item-categories">分类</a>
						</li>
					
						<li class="menu-tags">
							<a href="/tags" class="menu-item-tags">标签</a>
						</li>
					
						<li class="menu-about">
							<a href="/about" class="menu-item-about">关于</a>
						</li>
					

					
						<li class="menu-search">
							<a href="javascript:;" class="popup-trigger" title="Search">搜索</a>
						</li>
					
				</ul>			
			</div>				
		</div>

		<div class="h-body">	
			<!-- motto -->
			
				<div id="page-motto">
					<p class="motto">
						
					</p>
				</div>
			

			<div id="navigation-H">
				<!-- Page title -->
				<p>
					
						当前文章&nbsp;:&nbsp;《面试宝典二》
					
				</p>
				<!-- Progress bar -->
				<div id="progress-bar"></div>

				<!-- Progress percent -->
				<div id="progress-percentage">
					<h1>0.0%</h1>
				</div>
			</div>
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<ul>
				<!-- <li>
					<a><i class="fa fa-camera-retro" onclick="changeHeaderBg()"></i>切换背景</a>
				</li> -->
				<li>
					<a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down"></i>继续阅读</a>
				</li>
				<!-- <li>
					<a href="https://github.com/Sariay/hexo-theme-Annie" target="_blank"><i class="fa fa-download"></i>克隆主题</a>
				</li> -->
			</ul>
		</div>
		
		<!-- This is only a demo, please go to "https://time.is" to set your city time! -->
<style type="text/css">
	.header-date {
		position: absolute;
		left: 40px;
		bottom: 30px;
		writing-mode: tb-rl;
		font-size: 36px;
	}	
	.header-date a {
		border-bottom: none;
	}
	@media only screen and (max-width: 768 ) {
		.header-date {
			position: absolute;
			left: 40px;
			bottom: 30px;
			writing-mode: tb-rl;
			font-size: 20px;
		}			
	}
</style>
<div class="header-date">
	<a href="https://time.is/Beijing" id="time_is_link" rel="nofollow"></a>
	<span id="Beijing_z43d"></span>
</div>
<script src="//widget.time.is/zh.js"></script>
<script>
	time_is_widget.init({
		Beijing_z43d:{
			template:"DATE", 
			date_format:"year年 monthname dnum日"
		}
	});
</script>
</div></header>

<!-- Navigation in div(id="navigation-H") -->
<a class="nav-trigger">
	<span></span>
</a>

<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<h3>Navigation</h3>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	<div class="nav-body">
		<ul>
			
				<li class="menu-home">
					<a href="/" class="menu-item-home">主页</a>
				</li>
			
				<li class="menu-archive">
					<a href="/archives" class="menu-item-archive">归档</a>
				</li>
			
				<li class="menu-categories">
					<a href="/categories" class="menu-item-categories">分类</a>
				</li>
			
				<li class="menu-tags">
					<a href="/tags" class="menu-item-tags">标签</a>
				</li>
			
				<li class="menu-about">
					<a href="/about" class="menu-item-about">关于</a>
				</li>
			

			
				<li class="menu-search">
					<a href="javascript:;" class="popup-trigger" title="Search">搜索</a>
				</li>
			
		</ul>
	</div>

	<div class="nav-footer">
		<ul>
	
		
			<li>
				<a href="https://github.com/ccOnTheWay/wiki" title="Github" target="_blank">
					<i class="fa fa-github"></i>
				</a>
			</li>
		
		
		
			<li>
				<a href="mailto:fengxicai@fengxicai.cn" title="Email" target="_blank">
					<i class="fa fa-envelope-o"></i>
				</a>
			</li>
		

		
		
	 
</ul>
	</div>
</nav>

		
		<!--main-->
		<main>
			<div class="layout-post">
	
	
	<div class="article-title">
		
	<a href="/2019/03/27/面试宝典二/" itemprop="url">
		面试宝典二
	</a>

	</div>

	<div class="article-meta">
		<span>
			
	发布于
	<a href="/2019/03/27/面试宝典二/" itemprop="url">
		<time datetime="2019-03-27T03:49:04.000Z" itemprop="datePublished">
	  		2019-03-27
	  </time>
	</a> 

	/
	更新于
	<a href="/2019/03/27/面试宝典二/" itemprop="url">
		<time datetime="2019-03-27T03:49:04.000Z" itemprop="dateUpdated">
	  		2019-03-27
	  </time>
	</a> 	

		</span>
		/
		<span>
			<i class="fa fa-tags"></i>
			
	
		<a href="/tags/面试手册/" class=" ">
			面试手册
		</a>
	
		
		</span>
		/
		

    <span class="leancloud_visitors" id="/2019/03/27/面试宝典二/_visitors" data-url="/2019/03/27/面试宝典二/" data-title="面试宝典二">
        热度
        <i class="leancloud_visitors_count" id="leancloud_visitors_count">0</i>
    </span>
    
    /



    <span class="leancloud_likes" id="/2019/03/27/面试宝典二/_likes" data-url="/2019/03/27/面试宝典二/" data-title="面试宝典二" rel="unlike">
        喜欢
        <i class="fa fa-heart"></i>
        <i class="leancloud_likes_count" id="leancloud_likes_count">0</i>
    </span>

	</div>

	<div class="article-content" id="article-content">
		<p>六十四、    请实现鼠标点击任意标签，alert该标签的名称（注意兼容性）</p>
<pre><code>function elementName(evt){
        evt = evt|| window.event;
        var selected = evt.target || evt.srcElement;
            alert(selected.tagName);
}
</code></pre><p>六十五、    对string对象进行扩展，使其具有删除前后空格的方法</p>
<pre><code>String.prototype.trim = function() {
return     this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
</code></pre><p>六十六、    常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？<br>1)bootstrap, easy UI, highcharts和echarts，  jqueryUI , jquery、angular.js,  vue.js, reactjs等。<br>2)前端开发工具：gulp  webpack<br>3)轮播插件，拖拽插件</p>
<p>六十七、    用一句话概述您的优点，用一句话概述您的缺点<br>自由发挥</p>
<p>六十八、    描述下你对js闭包。面向对象、继承的理解<br>1）闭包理解：<br>  个人理解：闭包就是能够读取其他函数内部变量的函数；<br>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念<br>闭包有三个特性：<br>1.函数嵌套函数<br>2.函数内部可以引用外部的参数和变量<br>3.参数和变量不会被垃圾回收机制回收<br>闭包常见用途：<br>创建特权方法用于访问控制<br>事件处理程序及回调<br>2） 面向对象：<br>    面向对象编程，即OOP，是一种编程范式，满足面向对象编程的语言，一般会提供类、封装、继承等语法和概念来辅助我们进行面向对象编程。<br> 参考：<br><a href="http://www.ruanyifeng.com/blog/2010/05/object一oriented_javascript_encapsulation.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/05/object一oriented_javascript_encapsulation.html</a><br>3）继承：<br>对象继承分两种情况，一种是构造函数的继承，一种是原型（prototype）的继承：<br>1．    构造函数的继承，比较简单，只需要在子对象中添加代码：parent.apply(this, arguments);<br>关于原型的继承最优化的方法，利用空对象作为中介<br>2．    拷贝继承<br>可参考：<br><a href="https://segmentfault.com/a/1190000002440502" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002440502</a><br><a href="http://blog.csdn.net/james521314/article/details/8645815" target="_blank" rel="noopener">http://blog.csdn.net/james521314/article/details/8645815</a><br>六十九、    你做的页面在哪些浏览器测试过？这些浏览器的内核分别是什么？<br>IE内核浏览器：360，傲游，搜狗，世界之窗，腾讯TT。<br>非IE内核浏览器：firefox opera safari chrome 。<br>IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink（WebKit的分支）、Opera内核原为Presto，现为Blink；<br>七十、    写出几种IE6 bug的解决方法<br>1）png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.<br>2）IE6双倍边距bug：在该元素中加入display:inline 或 display:block<br>  3）像素问题 使用多个float和注释引起的 使用dislpay:inline 一3px<br>  4）超链接hover 点击后失效  使用正确的书写顺序 link visited hover active<br>  5）z一index问题 给父级添加position:relative<br>  6）Min一height 最小高度 ！Important 解决’ 7.select 在ie6下遮盖 使用iframe嵌套<br>  7）为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line一height:1px）<br>七十一、    清楚浮动的几种方法，各自的优缺点<br>1、    父级div定义伪类:after和zoom</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
 　  .div1{background:#000080;border:1px solid red;}
    .div2{background:#800080;border:1px solid red;height:100px;margin一top:10px}
 　  .left{float:left;width:20%;height:200px;background:#DDD}
 　  .right{float:right;width:30%;height:80px;background:#DDD}
　   /*清除浮动代码*/
 　  .clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0}
 　  .clearfloat{zoom:1}
&lt;/style&gt;
&lt;div class=&quot;div1 clearfloat&quot;&gt;
　　&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;
　　&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;
     div2
&lt;/div&gt;
</code></pre><p>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题。<br>优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）。<br>缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持。<br>建议：推荐使用，建议定义公共类，以减少CSS代码。<br>2、    父级div定义overflow:hidden</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
 　 .div1{background:#000080;border:1px solid red;/*解决代码*/width:98%;overflow:hidden}
      .div2{background:#800080;border:1px solid red;height:100px;margin一top:10px;width:98%}
 　 .left{float:left;width:20%;height:200px;background:#DDD}
 　 .right{float:right;width:30%;height:80px;background:#DDD}
&lt;/style&gt;
&lt;div class=&quot;div1&quot;&gt;
　　&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;
　　&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;
　　div2
&lt;/div&gt;
</code></pre><p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度。<br>优点：简单，代码少，浏览器支持好。<br>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。<br>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。<br>3、    结尾处加空div标签clear:both</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
　   .div1{background:#000080;border:1px solid red}
　   .div2{background:#800080;border:1px solid red;height:100px;margin一top:10px}
 　  .left{float:left;width:20%;height:200px;background:#DDD}
　   .right{float:right;width:30%;height:80px;background:#DDD}
　   /*清除浮动代码*/
　   .clearfloat{clear:both}
&lt;/style&gt;
&lt;div class=&quot;div1&quot;&gt;
　　&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;
　　&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;
　　&lt;div class=&quot;clearfloat&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;
　　div2
&lt;/div&gt;
</code></pre><p>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度。<br>优点：简单，代码少，浏览器支持好，不容易出现怪问题。<br>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽。<br>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法。<br>4、    父级div定义height</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
　　   .div1{background:#000080;border:1px solid red;/*解决代码*/height:200px;}
　　   .div2{background:#800080;border:1px solid red;height:100px;margin一top:10px}
 　　  .left{float:left;width:20%;height:200px;background:#DDD}
　　   .right{float:right;width:30%;height:80px;background:#DDD}
&lt;/style&gt;
&lt;div class=&quot;div1&quot;&gt;
　　&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;
　　&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;
　　div2
&lt;/div&gt;
</code></pre><p>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。<br>优点：简单，代码少，容易掌握。<br>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题。<br>建议：不推荐使用，只建议高度固定的布局时使用。<br>5、    父级div定义overflow:auto</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
 　　  .div1{background:#000080;border:1px solid red;
         /*解决代码*/width:98%;overflow:auto}
 　.div2{background:#800080; border:1px solid red; height:100px; margin- top:10px;width:98%}
 　　  .left{float:left;width:20%;height:200px;background:#DDD}
　　   .right{float:right;width:30%;height:80px;background:#DDD}
&lt;/style&gt;
&lt;div class=&quot;div1&quot;&gt;
　　&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;
　　&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;
　　div2
&lt;/div&gt;
</code></pre><p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度。<br>优点：简单，代码少，浏览器支持好。<br>缺点：内部宽高超过父级div时，会出现滚动条。<br>建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。</p>
<p>七十二、    Javascript的typeof返回哪些数据类型；列举3种强制类型转换和2中隐式类型转换<br>1）返回数据类型</p>
<pre><code>undefined
string
boolean
number
symbol(ES6)
Object
Function
</code></pre><p>2）强制类型转换<br>Number(参数)  把任何类型转换成数值类型。<br>parseInt(参数1，参数2)  将字符串转换成整数<br>parseFloat()将字符串转换成浮点数字<br>string(参数)：可以将任何类型转换成字符串<br>Boolean()  可以将任何类型的值转换成布尔值。<br>3）隐式类型转换<br>1.四则运算<br>加法运算符+是双目运算符，只要其中一个是String类型，表达式的值便是一个String。<br>对于其他的四则运算，只有其中一个是Number类型，表达式的值便是一个Number。<br>对于非法字符的情况通常会返回NaN：<br>‘1’ <em> ‘a’     // =&gt; NaN，这是因为parseInt(a)值为NaN，1 </em> NaN 还是 NaN<br>2.判断语句<br>判断语句中的判断条件需要是Boolean类型，所以条件表达式会被隐式转换为Boolean。   其转换规则同Boolean的构造函数。比如：<br>var obj = {};if(obj){<br>    while(obj);}<br>3.Native代码调用<br>JavaScript宿主环境都会提供大量的对象，它们往往不少通过JavaScript来实现的。  JavaScript给这些函数传入的参数也会进行隐式转换。例如BOM提供的alert方法接受String类型的参数：</p>
<pre><code>alert({a: 1});    // =&gt; [object Object]
</code></pre><p>七十三、    写出3个使用this的典型应用<br>1.</p>
<pre><code>function Thing() { }
 Thing.prototype.foo = &quot;bar&quot;;
 Thing.prototype.logFoo = function () {
      console.log(this.foo);
 }
 Thing.prototype.setFoo = function (newFoo) {
      this.foo = newFoo;
  }
  var thing1 = new Thing(); 
  var thing2 = new Thing();
 thing1.logFoo(); //logs &quot;bar&quot;
 thing2.logFoo(); //logs &quot;bar&quot;
 thing1.setFoo(&quot;foo&quot;);
 thing1.logFoo(); //logs &quot;foo&quot;;
 thing2.logFoo(); //logs &quot;bar&quot;;
 thing2.foo = &quot;foobar&quot;;
 thing1.logFoo(); //logs &quot;foo&quot;;
 thing2.logFoo(); //logs &quot;foobar&quot;;

2.
function Thing1() { }
  Thing1.prototype.foo = &quot;bar&quot;;
  function Thing2() {
     this.foo = &quot;foo&quot;;
 }
  Thing2.prototype = new Thing1();
  function Thing3() {}
  Thing3.prototype = new Thing2();
  var thing = new Thing3();
  console.log(thing.foo); //logs &quot;foo&quot;

3.
function Thing() {}
  Thing.prototype.foo = &quot;bar&quot;;
  Thing.prototype.logFoo = function () { 
      function doIt() {
          onsole.log(this.foo);
       }
      doIt.apply(this);
  }
 function doItIndirectly(method) {
method();
 }
var thing = new Thing();
doItIndirectly(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>七十四、    对前端界面工程师这个职位是怎么理解的？它的前景怎样？<br>前端工程师属于一个比较新兴的技术，各种技术层出不穷，随着客户体验的重要性前端需要掌握的技能也越来越多，对前端的要求也越来越多，而且我们前端是最贴近用户的程序员，主要负责实现界面交互，提升用户体验，而且有了Node.js，前端可以实现服务端的一些事情，针对服务器的优化、拥抱最新前端技术，除了掌握必要的技能还要掌握用户的心理，善于沟通。<br>前景：前景无疑是值得肯定的，也需要我们时刻关注最新的技术，这会是一个时刻都在学习的道路<br>七十五、    Eval函数的作用<br>   eval可以将字符串生成语句执行，一般执行动态的js语句。<br>   eval的使用场合：有时候我们预先不知道要执行什么语句，只有当条件和参数给时才知道执行什么语句，这时候eval就派上用场了。<br>七十六、    标签上title与alt属性的区别是什么<br>title 是鼠标放上去的额外信息<br>alt 是图片不能正常显示的时候，用文字代替<br>七十七、    对WEB标准以及w3c的理解与认识？<br>Web标准就是将页面的解构、表现和行为各自独立实现，w3c对标注提出了规范化的要求<br>1.对结构的要求：（标签规范可以提高搜索引擎对页面的抓取效率，对SEO很有帮助）<br>1）标签字母要小写；<br>2）标签要闭合；<br>3）标签不允许随意嵌套。<br>2.对css和js的要求：<br>1）尽量使用外联css样式表和js脚本，使结构、表现和行为分成三块，符合规范，同时提高页面渲染速度，提高用户体验；<br>2）样式尽量少用行间样式表，使结构与表现分离，标签的id和class命名要做到见文知义，标签越少，加载越快，用户体验更高，代码维护更简单，便于改版；<br>3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性<br>七十八、    Css选择符有哪些？哪些属性可以继承？优先级算法如何计算？<br>    1.id选择器（ # myid）<br>    2.类选择器（.myclassname）<br>    3.标签选择器（div, h1, p）<br>    4.相邻选择器（h1 + p）<br>    5.子选择器（ul &lt; li）<br>    6.后代选择器（li a）<br>    7.通配符选择器（ * ）<br>    8.属性选择器（a[rel = “external”]）<br>    9.伪类选择器（a: hover, li: nth 一 child）</p>
<p>可继承： font一size font一family color,;<br>不可继承 ：border padding margin width height<br>优先级就近原则，样式定义最近者为准；载入样式以最后载入的定位为准;<br>优先级为:  !important &gt;  id &gt; class &gt; tag<br> important 比 内联优先级高<br>七十九、    请戳出ie6/7下特有的cssbug<br>一：li边距“无故” 增加<br>设置ul的显示形式为<em>display:inline一block;即可，前面加</em>是只 针对IE6/IE7有效<br>二：IE6 不支持min一height属性，但它却认为height就是最小高度<br>使用ie6不支持但其余浏览器支持的属性!important。<br>三:Overflow:<br>在IE6/7中，overflow无法正确的隐藏有相对定位position:relative;的子元素。解决方法就是给外包容器.wrap加上position:relative;。<br>四：border：none 在IE6不起作用： 写成border：0 就可以了<br>五:100%高度<br>在IE6下，如果要给元素定义100%高度，必须要明确定义它的父级元素的高度，如果你需要给元素定义满屏的高度，就得先给html和body定义 height:100%;。<br>六:双边距 Bug<br>当元素浮动时，IE6会错误的的把浮动方式的margin值双倍计算，给float的元素添加一个display：inline<br>七：躲猫猫bug<br>定义了:hover的链接，当鼠标移到那些链接上时，在IE6下就会触发躲猫猫。<br>    1.在（那个未浮动的）内容之后添加一个<span style="”clear:" both;”></span><br>    2.触发包含了这些链接的容器的hasLayout，一个简单的方法就是给其定义height:1%;<br>八:IE6 绝对定位的元素1px 间距bug<br>当绝对定位的父元素或宽度为奇数时，bottom和right会多出现1px，<br>解决方案，针对IE6进行hack处理<br>八十、    如何将一个元素600毫秒的速度缓慢向上滑动显示？<br>如果需要在父元素底部向上，可以利用margin一top 把子元素，挤下去，同事父元素设置隐藏，然后改变margintop的值也可以利用定来做，把子元素定位最下边</p>
<pre><code>(function(){
        var oDiv = document.createElement(&#39;div&#39;);
        oDiv.style.width = &#39;100px&#39;;
        oDiv.style.height = &#39;100px&#39;;
        oDiv.style.backgroundColor = &#39;red&#39;;
        oDiv.style.position = &#39;absolute&#39;;
        oDiv.style.marginTop = 100 + &#39;px&#39;;
        document.body.appendChild(oDiv);
        var timer = setInterval(function(){
            var m = parseInt(oDiv.style.marginTop);
            if (m == 0 ) {
                clearInterval(timer);
                return;
            }
            oDiv.style.marginTop = parseInt(oDiv.style.marginTop) 一 1 + &#39;px&#39;;
        },600);
    })();
</code></pre><p>八十一、    写一个获取非行间样式的函数</p>
<pre><code>Function getStyle(obj, attr){
    If(obj.currentStyle){
        return obj.currentStyle[attr];
}else{
        return getComputedStyle(obj,false)[attr];
}
}
</code></pre><p>八十二、    请用正则表达式验证数字<br><code>/[0一9]*$/</code><br>八十三、    为什么利用多个域名来提供网站资源会更有效？<br>1)    突破浏览器的并发限制（浏览器同一域名最大的并发请求数量为6个，ie6为2个）<br>2)    节约cookie带宽<br>3)    CDN缓存更方便<br>4)    防止不必要的安全问题（尤其是cookie的隔离尤为重要）<br>5)    节约主机域名连接数，优化页面响应速度<br>八十四、    你如何从浏览器的URL中获取参数信息<br>浏览器宿主环境中，有一个location对象，同时这个对象也是window对象和document对象的属性。<br>location对象中提供了与当前窗口加载的文档有关的的信息，即URL信息。<br>    如  <a href="https://www.baidu.com/api/sousu?search=baidu&amp;id=123#2" target="_blank" rel="noopener">https://www.baidu.com/api/sousu?search=baidu&amp;id=123#2</a><br>        location.href: 完整URL<br>        location.protocol: 返回协议（https:）<br>        location.host: 返回服务器名称和端口号（<a href="http://www.baidu.com）" target="_blank" rel="noopener">www.baidu.com）</a><br> location.hostname: 返回服务器名称（<a href="http://www.baidu.com）" target="_blank" rel="noopener">www.baidu.com）</a><br> location.port:返回服务器端口号（http默认80，https默认443）<br> location.pathname:返回URL中的目录和文件名（api/sousu）<br> location.search:返回查询字符串（?search=baidu&amp;id=123#2）<br> location.hash:返回hash值（#2）<br>八十五、    手机端文字大小用什么单位<br>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可<br>对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备<br>八十六、    是否做过有上百图层的psd切图？ps隐藏其他图层，只显示其中一个图层的快捷键<br>Alt + 当前图层前眼睛<br>八十七、    浏览器标准模式和怪异模式之间的区别是什么？<br>这是个历史遗留问题，W3C标准推出前，旧的页面都是根据旧的渲染方式对页面进行渲染的，因此在W3C标准推出后为了保证旧页面的正常显示，保持浏览器的兼容性，这样浏览器上就产生了能够兼容W3C标准渲染的严格模式和保证旧页面显示的怪异模式的标准兼容模式。<br>    具体表现：<br>1.在严格模式中 ：width是内容宽度 ，元素真正的宽度 = margin一left + border一left一width + padding一left + width + padding一right + border一right一 width +  margin一right;<br>在怪异模式中 ：width则是元素的实际宽度 ，内容宽度 = width 一 ( padding一left + padding一right + border一left一width + border一right一width)<br>2）可以设置行内元素的高宽<br>    在标准模式下，给span等行内元素设置wdith和height都不会生效，而在怪异模式下，则会生效。<br>3）可设置百分比的高度<br>    在标准模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。<br>4）用margin:0 auto设置水平居中在IE下会失效<br>    使用margin:0 auto在标准模式下可以使元素水平居中，但在怪异模式下却会失效, 怪异模式下的解决办法，用text一align属性:<br>   body{text一align:center};#content{text一align:left}<br>5）怪异模式下设置图片的padding会失效<br>6）怪异模式下Table中的字体属性不能继承上层的设置<br>7）怪异模式下white一space:pre会失效<br>八十八、    Javascript同源策略<br>同源策略是Javascript重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓的同源就是同协议，同主机名，同端口号。<br>它的精髓很简单：它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。<br>八十九、    为什么要有同源限制？<br>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。<br>缺点：<br>现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。<br>九十、    了解响应式布局吗？请大体说一说<br>响应式布局概念：Responsive design，意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。<br>    设计步骤：<br>1．设置meta标签<br>2．根据媒体查询设置样式<br>3．设置多种视图宽度<br>4．注意点：<br>5．宽度使用百分比<br>6．处理图片缩放问题<br>九十一、    身为以为web前端工程师，你肯定知道现在最流行的前端技术吧，有那些？<br>Vuejs2.0/Angular2.0/React Native /es6//Nodejs<br>http2<br>gulp/webpack<br>九十二、    请简述为什么要使用数据库的事务<br>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>原子性（Atomic）（Atomicity)<br>　　事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。<br>　　一致性（Consistent）(Consistency)<br>　　事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。<br>　　隔离性（Insulation）(Isolation)<br>　　由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为隔离性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。<br>　　持久性（Duration）(Durability）<br>　　事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。<br>九十三、    聊一聊前端存储。<br>老朋友cookie<br>短暂的 sessionStorage<br>简易强大的localStorage<br>websql与indexeddb<br>详细参见：<a href="https://segmentfault.com/aZ1190000005927232" target="_blank" rel="noopener">https://segmentfault.com/aZ1190000005927232</a><br>九十四、    BFC<br>w3c规范中的BFC定义：<br>浮动元素和绝对定位元素，非块级盒子的块级容器（例如inline一blocks, table一cells,和 table一captions),以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的 BFC (块级格式上下文）。<br>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们 的margin值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。<br>在BFC中，每一个盒子的左外边缘（margin一left)会触碰到容器的左边缘(border一left)(对于 从右到左的格式来说，则触碰到右边缘）。<br>BFC的通俗理解：<br>首先BFC是一个名词，是一个独立的布局环境，我们可以理解为一个箱子（实际上是看不见 摸不着的），箱子里面物品的摆放是不受外界的影响的。转换为BFC的理解则是：BFC中的 元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元 素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元 素所组成）都会垂直的沿着其父元素的边框排列。<br>详细参见：<br><a href="http://www.w3cplus.com/css/understanding一bfc一and一margin一collapse.html" target="_blank" rel="noopener">http://www.w3cplus.com/css/understanding一bfc一and一margin一collapse.html</a><br><a href="https://www.zhihu.com/question/28433480" target="_blank" rel="noopener">https://www.zhihu.com/question/28433480</a><br>一一一一一一一一前端工程化一一一一一<br>九十五、    场景：你是第一天来公司上班的，项目代码托管在 GitLab，项目地址：<a href="mailto:git@lab.com" target="_blank" rel="noopener">git@lab.com</a>:org/project.git，现在有一处代码需要你修改。请完成此项任务中，与 git/gitlab相关的操作步骤。<br>第一步：$&gt; ssh一keygen 一t rss 一C <a href="mailto:zhangsan@abc.com" target="_blank" rel="noopener">zhangsan@abc.com</a><br>第二步：拷贝公钥到gitlab<br>第三步：<br>$&gt; git config —global user.name zhangsan<br>$&gt; git config —global user.email <a href="mailto:zhangsan@abc.com" target="_blank" rel="noopener">zhangsan@abc.com</a><br>第四步：$&gt; git clone <a href="mailto:git@lab.com" target="_blank" rel="noopener">git@lab.com</a>:org/project.git<br>第五步：$&gt; git checkout 一b project一20170227一zhangsan一bugfix<br>第六步：修改代码<br>第七步：git status<br>第八步：git add .<br>第九步：git commit 一am ‘bugfix’<br>第十步：<br>    git push 一一set一upstream origin project一20170227一zhangsan一bugfix<br>九十六、    CSS，JS代码压缩，以及代码CDN托管，图片整合<br>CSSJS代码压缩：<br>可以应用gulp的gulp一uglify, gulp一minify一css模块完成；可以应用webpack的 UglifyJsPlugin 压缩插件完成。<br>CDN:<br>内容分发网络(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请 求的重定向和内容管理4个要件。主要特点有：本地Cache加速，镜像服务，远程加速，带 宽优化。关键技术有：内容发布，内容路由，内容交换，性能管理。CDN网站加速适合以 咨询为主的网站。CDN是对域名加速不是对网站服务器加速。CDN和镜像站比较不需要访 客手动选择要访问的镜像站。CDN使用后网站无需任何修改即可使用CDN获得加速效果。<br>如果通过CDN后看到的网页还是旧网页，可以通过URL推送服务解决，新增的网页和图片 不需要URL推送。使用动态网页可以不缓存即时性要求很高的网页和图片。CDN可以通过 gi域SVN来管理。<br>图片整合<br>减少网站加载时间的最有效的方式之一就是减少网站的HTTP请求数。实现这一目标的一个 有效的方法就是通过CSS Sprites ——将多个图片整合到一个图片中，然后再用CSS来定 位。缺点是可维护性差。可以使用百度的fis/webpack来自动化管理sprite。<br>九十七、    如何利用webpack把代码上传服务器以及转码测试?<br>代码上传：<br>可以使用sftp一webpack一plugin,但是会把子文件夹给提取出来，不优雅。可以使用gulp +webpack来实现。<br>转码测试<br>webpack应用babel来对ES6转码，开启devtool: “source一map”来进行浏览器测试。应用 karma或mocha来做单元测试。<br>九十八、    项目上线流程是怎样的？<br>流程建议<br>一模拟线上的开发环境<br>本地反向代理线上真实环境开发即可。（apache, nginx, nodejs均可实现）<br>一模拟线上的测试环境<br>模拟线上的测试环境，其实是需要一台有真实数据的测试机，建议没条件搭daily的，就直接 用线上数据测好了，只不过程序部分走你们的测试环境而已，有条件搭daily最好。<br>一可连调的测试环境<br>可连调的测试环境，分为2种。一种是开发测试都在一个局域网段，直接绑hosts即可，不在 一个网段，就每人分配一台虚拟的测试机，放在大家都可以访问到的公司内网，代码直接往 上布即可。<br>一自动化的上线系统<br>自动化的上线系统，可以采用Jenkins。如果没有，可以自行搭建一个简易的上线系统，原 理是每次上线时都抽取最新的trunk或master，做一个tag，再打一个时间戳的标记，然后分 发到cdn就行了。界面里就2个功能，打tag,回滚到某tag,部署。<br>一适合前后端的开发流程<br>开发流程依据公司所用到的工具，构建，框架。原则就是分散独立开发，互相不干扰，连调 时有hosts可绑即可。<br>简单的可操作流程<br>一代码通过git管理，新需求创建新分支，分支开发，主干发布 一上线走简易上线系统，参见上一节<br>一通过gulp+webpack连到发布系统，一键集成，本地只关心原码开发<br>一本地环境通过webpack反向代理的server<br>一搭建基于linux的本地测试机，自动完成build+push功能<br>九十九、    工程化怎么管理的？<br>前端工程化可以自动化处理一些繁复的工作，提高开发效率，减少低级错误。<br>目前前端构建工具很多，综合比较来看，gulp相对来说更灵活，可以做更多的定制化任务，而webpack在模块化方面更完美一些<br>   gulp打造前端工程化方案，同时引入webpack来管理模块化代码，大致分工如下：<br>gulp：处理html压缩/预处理/条件编译，图片压缩，精灵图自动合并等任务<br>webpack：管理模块化，构建js/css。<br>    具体流程可参考： <a href="http://blog.csdn.net/java_goodstudy/article/details/52797322" target="_blank" rel="noopener">http://blog.csdn.net/java_goodstudy/article/details/52797322</a></p>
<p>一百、    git常用命令<br>Workspace:工作区<br> Index/Stage:暂存区<br>Repository:仓库区（或本地仓库）<br> Remote:远程仓库<br> git  init; (# 在当前目录新建一个Git代码库)<br> git  add （添加当前目录的所有文件到暂存区）<br> git  rm –cached [file] (# 停止追踪指定文件，但该文件会保留在工作区)<br> git  commit  [file1] [file2]  -m  [message] (# 提交暂存区的指定文件到仓库区 )<br> git   branch  -a (列出所有本地分支和远程分支)<br> git  checkout  [branch-name] (# 切换到指定分支，并更新工作区)<br>git  status( # 显示有变更的文件)<br>git  push  [remote] -tags (# 提交所有tag)<br>详细参见：<a href="http://www.ruanyifeng.com/blog/2015/12/git一cheat一sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git一cheat一sheet.html</a><br>一百〇一、    git与svn的区别<br>git是分布式的，svn不是。<br>git跟svn一样有自己的集中式版本库或服务器。但git更倾向于被使用于分布式模式，克隆版本库后即使没有网络也能够commit文件，查看历史版本记录，创建项目分支等，等网络再次连接上Push到服务器端。<br>git把内容按元数据方式存储，而svn是按文件。<br>所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。<br>git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。<br>git没有一个全局的版本号，svn有。<br>git的内容完整性优于svn。因为git的内容存储使用的是SHA-1哈希算法。<br>git可以有无限个版本库，svn只能有一个指定中央版本库。<br>当svn中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。<br>每一个git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）有问题，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！<br>一百〇二、    webpack 和 gulp 对比<br>Gulp就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与 压缩、mock数据等功能的一个前端自动化构建工具。说的形象点，“Gulp就像是一个产品的 流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管 理。”另外，Gulp是通过task对整个开发过程进行构建。<br>Webpack是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照 依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔， 等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比 如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS等。<br>Gulp和Webpack功能实现对比：从基本概念、启动本地Server、sass/less预编译、模块化 开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。<br>详细参见：<a href="http://www.tuicool.com/articles/e632EbA" target="_blank" rel="noopener">http://www.tuicool.com/articles/e632EbA</a><br>一百〇三、    webpack打包文件太大怎么办？<br>webpack把我们所有的文件都打包成一个JS文件，这样即使你是小项目，打包后的文件也 会非常大。可以从去除不必要的插件，提取第三方库，代码压缩，代码分割，设置缓存几个 方面着手优化。<br>详细参见：<a href="http://www.jianshu.com/p/a64735eb0e2b" target="_blank" rel="noopener">http://www.jianshu.com/p/a64735eb0e2b</a><br>一百〇四、    谈谈你对webpack的看法<br>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、JavaScript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。<br>webpack的两大特色：<br>1.code splitting（可以自动完成）<br>2.loader 可以处理各种类型的静态文件，并且支持串联操作<br>webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。<br>webpack具有requireJs和browserify的功能，但仍有很多自己的新特性：</p>
<ol>
<li>对 CommonJS 、 AMD 、ES6的语法做了兼容</li>
<li>对js、css、图片等资源文件都支持打包</li>
<li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</li>
<li>有独立的配置文件webpack.config.js</li>
<li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</li>
<li>支持 SourceUrls 和 SourceMaps，易于调试</li>
<li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活<br>8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快<br>一百〇五、    说说你对AMD和Commonjs的理解<br>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。<br>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。<br>一百〇六、    不想让别人盗用你的图片，访问你的服务器资源该怎么处理？<br>目前常用的防盗链方法主要有两种：<br>(1)    设置Referer:适合不想写代码的用户，也适合喜欢开发的用户（Referer是HTTP协议中的请求头，在跨页面访问的时候会带上。需要看看浏览器请求的Referer是http://还是https://，一般是http://）<br>(2)    签名URL:适合喜欢开发的用户<br>详细参见：<a href="https://yq.aliyun.com/articles/57931" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57931</a><br>一百〇七、    精灵图和base64如何选择？<br>css精灵，用于一些小的图标不是特别多，一个的体积也稍大，比如大于10K (这个没有严 格的界定）。<br>base64,用于小图标体积较小（相对于css精灵），多少都无所谓。字体图标，用于一些别 人做好的图标库（也有少数自己去做的）用起来比较方便，他的图标只能用于单色，图标用 只能于一种颜色。<br>一百〇八、    webpack怎么引入第三方的库？<br>拿jQuery为例：<br>entry: {<br>page: ‘path/to/page.js’,<br>jquery: ‘node—modules/jquery/dist/jquery.min.js’<br>}<br>new HtmlWebpaekPlugin({<br>filename: ‘index.html’,<br>template: ‘index.html’,<br>inject: true,<br>chunks: [‘jquery’,’page’] // 按照先后顺序插入 script 标签<br>})<br>一百〇九、    如果线上出现bug git怎么操作？<br>方法1：在当前主分支修改bug，暂存当前的改动的代码，目的是让工作空间和远程代码一致：<br>Git stash<br>修改完bug后提交修改：<br>git add .<br>git commit 一m “fix bug 1”<br>git push<br>从暂存区把之前的修改恢复，这样就和之前改动一样了<br>git stash pop<br>这时可能会出现冲突，因为你之前修改的文件，可能和bug是同一个文件，如果有冲突会提示：<br>Auto一merging xxx.Java<br>CONFLICT (content): Merge conflict in xxx.java<br>前往xxx.java解决冲突<br>注意stash pop意思是从暂存区恢复到工作空间，同时删除此条暂存记录。<br>方式2：拉一个新分支，老司机都推荐这样做，充分利用了git特性，先暂存一下工作空间改动：<br>git stash<br>新建一个分支，并且换到这个新分支<br>git branch fix_bug //新建分支<br>git checkout fix_bug //切换分支<br>这时候就可以安心的在这个fix_bug分支改bug了，改完之后：<br>git add .<br>git commit 一m “fix a bug”<br>切换到master主分支<br>git checkout master<br>从fix_bug合并到master分支<br>git merge fix_bug<br>提交代码<br>git push<br>然后从暂存区恢复代码<br>git stash pop<br>此时如有冲突，需要解决冲突<br>一百一十、    用过Nginx吗？都用过哪些？<br>nginx是一个高性能的HTTP和反向代理服务器。<br>常使用场景：<br>(1)    反向代理<br>(2)    网站负载均衡<br>详细参见：<a href="http://www.cnblogs.com/hobinly/p/6023883.html" target="_blank" rel="noopener">http://www.cnblogs.com/hobinly/p/6023883.html</a><br>移动端布局与适配<br>一百一十一、    iscroll安卓低版本卡顿，如何解决？<br>方案一：iScroll v5.1.3 设置momentum: true<br>方案二：配置probeType<br>方案三：开启硬价加速：给scroll元素增加css样式：一webkit一transform:translate3d(0,0,0);<br>方案四：判断手机版系统版本，应用原生CSS: overflow:scroll一y<br>一百一十二、    移动布局自适应不同屏幕的几种方式<br>(1)    响应式布局<br>(2)    100%布局（弹性布局）<br>(3)    等比缩放布局（rem)<br>一百一十三、    请说下移动端常见的适配不同屏幕大小的方法？<br>响应式布局<br>简而言之，就是页面元素的位置随着屏幕尺寸的变化而变化，通常会用百分比来定位，而在设计上需要预留一些可被“压缩”的空间。<br>Cover布局<br>就跟background一size的cover属性一样，保持页面的宽高比，取宽或高之中的较小者占满屏幕，超出的内容会被隐藏。此布局适用于主要内容集中在中部，边沿无重要内容的设计。<br>Contain布局<br>同样，也跟background一size的contain属性那样，保持页面的宽高比，取宽或高之中的较大者占满屏幕，不足的部分会用背景填充。个人比较推荐用这种方式，但在设计上需要背景为单色，或者是可平铺的背景。<br>一百一十四、    你们做移动端平时在什么浏览器上测试？<br>Chrome，Safari，微信X5, UC，其他手机自带浏览器<br>一百一十五、    说说移动端是如何调试的？<br>移动端调试：<br>(1)    模拟手机调试<br>(2)    真机调试之android手机+Chrome<br>(3)    真机调试之 iphone + safari ⑷UC浏览器<br>(1)    微信内置浏览器调试<br>(2)    debuggap<br>(3)    抓包<br>详细参考：<a href="https://segmentfault.eom/a/1190000005964730" target="_blank" rel="noopener">https://segmentfault.eom/a/1190000005964730</a><br>一百一十六、    ICONFONT使用及其利与弊？<br>把一些零散的icon做成字体。我们调用文字的时候，渲染出来的就是icon图像，这样的显示就是iconfont（字体图标）<br>好处：</li>
<li>iconfont图像放大后，不会失真。</li>
<li>iconfont节省流量</li>
<li>iconfont在颜色变幻方面很简单<br>缺点：</li>
<li>iconfont不能支持一个图像里面混入多重颜色</li>
<li>iconfont的使用没有使用图片那么直接，简单。<br>详细参见：<a href="https://segmentfault.com/a/1190000005904616" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005904616</a>? ea=953657<br>一百一十七、    说说移动端Web分辨率<br>从以下几个方面做答：<br>(1)    pc到移动，渲染的变迁<br>(2)    可以更改的布局宽度<br>(3)    再次变迁的像素<br>(4)    又一次变迁<br>(5)    是时候说说安卓了<br>详细参见：<a href="https://segmentfault.com/a/1190000005884985" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005884985</a><br>性能和效率<br>一百一十八、    你平时如何评测你写的前端代码的性能和效率。<br>Chrome DevTools的Timeline:是用来排查应用性能瓶颈的最佳工具。<br>Chrome DevTools的Audits:对页面性能进行检测，根据测试的结果进行优化。<br>第三方工具Yslow。<br>详细参见：<br><a href="http://www.cnblogs.com/一simon/p/5883336.html" target="_blank" rel="noopener">http://www.cnblogs.com/一simon/p/5883336.html</a><br><a href="http://blog.csdn.net/ivan0609/artide/details/45508365" target="_blank" rel="noopener">http://blog.csdn.net/ivan0609/artide/details/45508365</a><br><a href="http://www.wtoutiao.com/p/1305TZW.html" target="_blank" rel="noopener">http://www.wtoutiao.com/p/1305TZW.html</a><br>一百一十九、    如何优化页面，加快页面的加载速度(至少5条)<br>(1)    优化图片资源的格式和大小<br>(2)    开启网络压缩<br>(3)    使用浏览器缓存<br>(4)    减少重定向请求<br>(5)    使用CDN存储静态资源<br>(6)    减少DNS查询次数<br>(7)    压缩css和js内容<br>详细参见：<a href="http://www.mahaixiang.cn/wyzz/1589.html" target="_blank" rel="noopener">http://www.mahaixiang.cn/wyzz/1589.html</a><br>一百二十、    怎么保证多人开发进行内存泄漏的检查（内存分析 工具）<br>1)    使用xcode里面的Analyze进行静态分析<br>build setting —-》 automa —-》 mrc环境<br>product —-》 analyze —-》command + R<br>2)    为避免不必要的麻烦，多人开发的时候尽量使用 ARC<br>内存泄露：<br>参考：<a href="http://blog.csdn.net/panda_bear/article/details/8009421" target="_blank" rel="noopener">http://blog.csdn.net/panda_bear/article/details/8009421</a><br>一百二十一、    前后端性能如何调优？</li>
<li>减少http请求数</li>
<li>使用内容分布式网络</li>
<li>给头部添加一个失效期或者Cache一Control</li>
<li>Gzip压缩组件</li>
<li>把样式表放在前面</li>
<li>把脚本放在最后</li>
<li>不使用CSS表达式</li>
<li>使用外部的JavaScript和CSS</li>
<li>减少DNS的查询</li>
<li>缩小JavaScript和CSS<br>参考：<a href="http://blog.csdn.net/sonta/article/details/44454787" target="_blank" rel="noopener">http://blog.csdn.net/sonta/article/details/44454787</a><br>一百二十二、    浏览器http请求过多怎么解决？<br>(1)    合并JS、CSS文件<br>(2)    合并图片css sprite<br>(3)    使用 Image maps<br>(4)    data嵌入图片：如base64<br>(5)    使用CDN，减少http请求头<br>Web安全<br>一百二十三、    你所了解到的Web攻击技术<br>(1)    XSS攻击<br>(2)    CSRF攻击<br>(3)    网络劫持攻击<br>(4)    控制台注入代码<br>(5)    钓鱼<br>详细参见：<a href="http://blog.csdn.net/fengyinchao/article/details/52303118" target="_blank" rel="noopener">http://blog.csdn.net/fengyinchao/article/details/52303118</a></li>
</ol>
<p>一百二十四、    如何防止XSS攻击？<br>(1)    将前端输出数据都进行转义<br>(2)    将输出的字符串中的\反斜杠进行转义<br>(3)    从url中获取的信息，防止方法是由后端获取，在前端转义后再行输出<br>(4)    使用cookie的HttpOnly属性，保护好cookie<br>详细参见：<a href="http://blog.csdn.net/fengyinchao/article/details/52303118" target="_blank" rel="noopener">http://blog.csdn.net/fengyinchao/article/details/52303118</a><br>一百二十五、    项目中有没有用过加密，哪种加密算法？<br>项目中没有用过，但我了解几个加密算法：<br>(1)    RSA加密<br>(2)    MD5加密<br>(3)    SHA256加密<br>一百二十六、    聊一聊网页的分段传输与渲染<br>从下面几个方面说：<br>(1)    CHUNKED编码<br>(2)    BIGPIPE<br>(3)    分段传输与bigpipe适用场景<br>详细参见：<a href="https://segmentfault.com/a/1190000005989601" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005989601</a> ? ea=984496<br>一百二十七、    百度移动端首页秒开是如何做到的？<br>从几个方面优化：<br>(1)    静态文件放置<br>(2)    缓存<br>(3)    外链<br>(4)    缓存DOM<br>(5)    使用 iconfont<br>(6)    卡片的异步加载与缓存<br>(7)    不在首屏的就要异步化<br>(8)    少量静态文件的域名<br>详细参见：<a href="https://segmentfault.com/a/1190000005882953" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005882953</a><br>一百二十八、    前端速度统计（性能统计）如何做？<br>回答下面的两个问题：<br>(1)    网站都有哪些指标？<br>(2)    如何统计自己网站的这些指标？<br>详细参见：<a href="https://segmentfault.eom/a/1190000005869953" target="_blank" rel="noopener">https://segmentfault.eom/a/1190000005869953</a><br>架构<br>一百二十九、    如果让你来制作一个访问量很高的大型网站，你会如何来管理所有css、js文件、图片？<br>(1)    遵循自定的一套CSS，JS和图片文件和文件夹命名规范<br>(2)    依托采用的前端工程化工具，依照工具脚手架规范（gulp, webpack, grunt, yeoman)<br>(3)    依据采用的框架规范（Vue, React, jQuery)<br>一百三十、    如果没有框架、怎么搭建你的项目<br>应用原生JS自己尝试搭建一个MVC架构：<br>(1)基本模块<br>common:公共的一组件，下面的各模块都会用到<br>config:配置模块，解决框架的配置问题<br>startup:启动模块，解决框架和Servlet如何进行整合的问题<br>plugin:插件模块，插件机制的实现，提供IPlugin的抽象实现<br>routing:路由模块，解决请求路径的解析问题，提供了 IRoute的抽象实现和基本实现<br>controller:控制器模块，解决的是如何产生控制器<br>model:视图模型模块，解决的是如何绑定方法的参数<br>action: action模块，解决的是如何调用方法以及方法返回的结果，提供了IActionResult的 抽象实现和基本实现<br>view:视图模块，解决的是各种视图引擎和框架的适配<br>filter:过滤器模块，解决是执行Action,返回IActionResult前后的AOP功能，提供了 IFilter 的抽象实现以及基本实现<br>扩展模块filters：一些IFilter 的实现<br>results :―些IActionResult 的实现<br>routes :―些IRoute 的实现<br>plugins:—些 IPlugin 的实现 </p>
<p>一百三十一、    在选择框架的时候要从哪方面入手<br>影响团队技术选型有很多因素，如技术组成，新技术，新框架，语言及发布等。为了更好的 考量不同的因素，需要列出重要的象限，如开发效率、团队喜好，依次来决定哪个框架更适 合当前的团队和项目。上线时间影响框架选择，不要盲目替换现有框架。<br>(1)    jQuery<br>项目功能比较简单。并不需要做成一个单页面应用，就不需要MV*框架。项目是一个遗留 系统。与其使用其他框架来替换，不如留着以后重写项目。<br>(2)    AngularJS<br>当我们在制作一个应用，它对性能要求不是很高的时候，那么我们应该选择开发速度更快的 技术栈AngularJS，她拥有混合开发能力的ionic框架。对于复杂的前端应用来说，基于 Angular.js应用的运行效率，仍然有大量地改进空间。Angular2需要学习新的语言，需慎重 选择。<br>(3)    React<br>选择React有两个原因，一是通过Virtual DOM提高运行效率，二是通过组件化提高开发效 率。大型项目首选。选择React还有_个原因是：React Native、React VR等等，可以让 React运行在不同的平台之上。我们还能通过React轻松编写出原生应用，还有VR应用。<br>令人遗憾的是React只是一个View层，它是为了优化DOM的操作而诞生的。为了完成一 个完整的应用，我们还需要路由库、执行单向流库、web AP丨调用库、测试库、依赖管理库 等等，为了完整搭建出一个完整的React项目，我们还需要做大量的额外工作。<br>(4)    Vue.js<br>对于使用Vue.js的开发者来说，我们仍然可以使用熟悉的HTML和CSS来编写代码。并 且，Vue.js也使用了 Virtual D〇M、Reactive及组件化的思想，可以让我们集中精力于编写 应用，而不是应用的性能。<br>对于没有Angular和React经验的团队，并且规模不大的前端项目来说，Vue.js是一个非常 好的选择。<br>详细参见：<a href="https://zhuanlan.zhihu.com/p/25194137" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25194137</a><br>一百三十二、    聊一聊前端模板与渲染<br>(1)    页面级的渲染，后端模板<br>如smarty，这种方式的特点是展示数据快，直接后端拼装好数据与模板，展现到用户面前， 对SEO友好。<br>(2)    异步的请求与新增模板，前端模板<br>如Mustache, ArtTemplate,前端解析模板的引擎的语法，与后端解析模板引擎语法一致。 这样就达到了一份HTML前后端一起使用的效果。<br>详细参见：<a href="https://segmentfault.com/a/1190000005916423" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005916423</a></p>
<p>混合开发<br>一百三十三、    UIWebView和JavaScript之间是怎么交互的？<br>UlWebView是i〇S SDK中渲染网面的控件，在显示网页的时候，我们可以hack网页 然后显示想显示的内容。其中就要用至JavaScript的知识，而UlWebView与javascript交互的 方法就是 stringByEvaluatingJavaScriptFromString:<br>有了这个方法我们可以通过objc调用javascript,可以注入javascript。<br>UIWebView是iOS SDK中渲染网面的控件，在显示网页的时候，我们可以hack网页 然后显示想显示的内容。其中就要用至JavaScript的知识，而UIWebView与javascript交互的 方法就是stringByEvaluatingJavaScriptFromString,有了这个方法我们可以通过objc调用 javascript,可以注入 javascript<br>Js调用〇C方法原理就是利用UIWebView重定向请求，传一些命令到我们的 UIWebView,在UIWebView的delegate的方法中接收这些命令，并根据命令执行相应的objc 方法。这样就相当于在javascript中调用objc的方法。<br>在android中，我们有固有组件webview,经过设置可以让它支持我们的js的渲染，然 后在代码中设置（WebViewClient/WebChromeClient)让应用跳转页面时在本webview中跳 转，通过webview.loadurl (String str)方法可以在需要的地方加载我们前端的页面或者调用 前端所定义的方法（wv.loadUrl(“javascript:sendDataToAndroid(‘我是来自js的呦，你看到了 吗’)”);），我们再通过JavascriptInterface接口设置我们前端和android通讯的标识，<br>wv.addJavascriptInterface(new MJavascriptInterface(getApplicationContext()), “WebViewFunc”);<br>这样前端就可以在页面上调用我们的方法了，funl方法是在android中定义的 Window.WebViewFunc.fun1 ();<br>总之，前端和android或者ios进行结合开发，我们称之为混合开发，原理就是在原生 的开发语言中，我们提供了一个组件webview，这个组件就是我们的原生语言的浏览器，但 是我们得自行设置让其能够完美支持我们的应用，需要设置对应的标识，然后连接起来，我 们称之为 JavascriptInterfac。<br>一百三十四、    混合开发桥接api是怎么调用的，需要引入类库嘛？ 调用的对象是什么？<br>Hybrid框架结构<br>HyBrid App = H5 App + Native 框架<br>H5App用来实现功能逻辑和页面渲染 Native框架提供WebView和设备接口供H5调用<br>方案一重混合应用，在开发原生应用的基础上，嵌入WebView但是整体的架构使用 原生应用提供，一般这样的开发由Native开发人员和Web前端开发人员组成。Native开发人<br>员会写好基本的架构以及API让Web开发人员开发界面以及大部分的渲染。保证到交互设 计，以及开发都有一个比较折中的效果出来，优化得好也会有很棒的效果。<br>Hybrid App技术发展的早期，Web的运行性能成为主要瓶颈！<br>为解决性能问题Hybrid App走向‘‘重混”。<br>通过多WebView:实现流畅的多页加载和专场动画。<br>使用Navtive UI组件：框架、菜单、日期等。<br>‘‘重混”的优缺点 优点：<br>一提升了运行性能 一增强了交互体验<br>缺点一<br>一Web和Native技术交叉混杂 一需要同时掌握Web和Native技术，学习难度增加 一一个页面有Web组件也有Native组件，编程调试困难<br>需要引入各自需要的各种依赖工具<br>方案二：轻混合应用，使用PhoneGap、AppCan之类的中间件，以WebView作为用 户界面层，以Javascript作为基本逻辑，以及和中间件通讯，再由中间件访问底层API的方 式，进行应用开发。这种架构一般会非常依赖WebView层的性能。<br>随着时代的发展，手机硬件、浏览器技术、无线网络技术都得到了大幅的提升，H5已经可 以支持复杂应用，并拥有良好的运行性能。使用轻混方案的App也越来越多。<br>目前我们要学习的Hybrid App开发就是方案二，使用H5+Js+Native框架开发当前轻 混合应用。<br>Phonegap 引入phonegap.js 或者 cordova.js,对象为 navigator Dcloud引入引入mui.js或者其他的js组件，对象为plus apiloud引入各种第三方插件，对象为api<br>顺变提一下，2012年8月，微信公众平台的上线，重新定义了移动应用：移动应用 =Iphone App + Android App + 微信 App<br>一百三十五、    说一下你对支付，推送（远程，本地）的理解<br>消息的推送主要有两种：<br>一种是本地推送，主要应用在系统的工具中，例如：闹钟，生日提醒等；实现本地推 送需要以下三个步骤，</p>
<ol>
<li>实例化一个本地推送对象</li>
<li>设置通知对象的各个属性</li>
<li>添加本地推送对象<br>一种是远程消息推送，主要应用联网设备的信息推送，例如：邮件，各种软件的广告 或优惠信息的推送。远程推送比较复杂，需要使用开发者账号进行申请证书，获得实<br>现推送功能的配置文件，所以想要实现远程推送功能，必须要有开发者账号并且生成 配置文件</li>
<li>完成证书的申请和Xcode的配置</li>
<li>在Demo中注册远程服务对象，并设置其代理</li>
<li>找一个简单的App服务器进行消息推送（推荐使用:PushMeBaby, gitup网站上就有）</li>
<li>运行 PushMeBaby<br>参考网址：<a href="http://blog.csdn.net/u014642572/article/details/26857717" target="_blank" rel="noopener">http://blog.csdn.net/u014642572/article/details/26857717</a><br>远程推送流程图如下</li>
</ol>
<p>一百三十六、    什么是代理和通知，写一下他们基本的实现方式<br>代理：“一对一”，对同一个协议，一个对象只能设置一个代理delegate<br>六个步骤：<br>1．声明一个协议,定义代理方法<br>2．遵循协议<br>3．设置一个代理对象<br>4．调用代理方法<br>5．给代理赋值<br>6．实现代理方法<br>注意事项：<br>1．单例对象不能用代理；<br>2．代理执行协议方法时要使用respondsToSelector检查其代理是否符合<br>3．协议(检查对象能否响应指定的消息),以避免代理在回调时因为没有实现方法而造成程序崩溃<br>使用场景：<br>公共接口，方法较多也选择用delegate进行解耦 iOS最常用tableViewDelegate, textViewDelegate iOS有很多例子比如常用的网络库AFNetwork，ASIHTTP库， UlAlertView 类。</p>
<p>通知：一对一 一对多 传值<br>四个步骤：<br>1．发送通知<br>2．创建监听者<br>3．接收通知<br>4．移除监听者<br>使用场景：<br>1一很多控制器都需要知道一个事件，应该用通知；<br>2 一相隔多层的两个控制器之间跳转<br>注意事项：<br>1．一旦接收消息的对象多了，就难以控制了，可能有你不希望的对象接收了消息并做了处理<br>2．创建了观察者，在dealloc里面一定要移除；</p>
<p>Block :  Block是i〇S4.0+和Mac OS X 10.6+引进的对C语言的扩展，用来实现匿名函数的特性。Blocks语法块代码以闭包得形式将各种内容进行传递，可以是代码，可以是数组 无所不能。闭包就是能够读取其它函数内部变量的函数。就是在一段请求连续代码中可以看 到调用参数（如发送请求）和响应结果。所以采用Block技术能够抽象出很多共用函数，提 高了代码的可读性，可维护性，封装性。<br>使用场景：<br>—: 动画<br>二：数据请求回调<br>三：枚举回调<br>四：多线程gcd<br>注意事项：Iblock需要注意防止循环引用<br>参考网址：<a href="http://www.cnblogs.com/wenboliu/articles/5422033.html" target="_blank" rel="noopener">http://www.cnblogs.com/wenboliu/articles/5422033.html</a><br>一百三十七、    UIViewController 的生命周期<br>1．通过alloc init分配内存，初始化controller.<br>2．loadView （loadView方法默认实现[super loadView]<br>如果在初始化controller吋指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件，如果 没传xib文件名，默认会加载跟controller同名的xib文件，如果没找到相关联的xib文件，就会创建一个空白的UIView,然后赋給controller的view）<br>3．viewDidLoad (当loadView创建完view之后，此吋view已经完成加载了，会调用 viewDidLoad方法；一般我会在这里做界面上的初始化操作，比如添加按钮，子视图，等等.）<br>4．viewWillAppear (当view在load完之后，将要显示在屏幕之前会调用这个方法，在重写这些方法吋候最好先调用一下系统的方法之后在做操作。）<br>5．viewDidAppear (当view已经在屏幕上显示出来之后，会调用这个方法，当一个视图被移除屏幕并且销毁的吋候）<br>6．viewWillDisappear (当视图将要从屏幕上移除吋候调用 )<br>7．viewDidDisappear (当视图已经从屏幕上移除吋候调用 )<br>8．Dealloc (view被销毁吋候调用，如果是手动管理内存的话，需要释放掉之前在init和 viewDidLoad中分配的内存（类似alloc,new,copy) ; dealloc方法不能甶我们主动调用，必须等引用计数为0吋候甶系统调用.）<br>9．参考网址： <a href="http://www.cnblogs.eom/wujy/p/5822329.html" target="_blank" rel="noopener">http://www.cnblogs.eom/wujy/p/5822329.html</a><br>一百三十八、    rem布局字体太大怎么处理？<br>一般情况下我们设置了html根节点的字体大小作为rem单位的一个基本标准，那么我 们可以紧接着在body标签内设置一个字体大小为该应用的基本字体大小<br>针对于一些机型如果一开始就显示的字体不正常，我们可以通过判断机型然后加载不同的样式</p>
<pre><code>〈script language=&quot;javascript&quot;&gt;
window.onload = function() { 
alert(“1”);
var u = navigator.userAgent;
if(u.index〇f(&#39;Android&#39;) &gt; 一1 ||  u.indexOf(&#39;Linux&#39;) &gt; 一1) { //安卓手机
alert(&quot;安卓手机&quot;)；
} else if(u.index〇f(&#39;iPhone&#39;) &gt; 一1) { //苹果手机 
alert(&quot;苹果手机&quot;)；
} else if(u.index〇f(&#39;Windows Phone&#39;) &gt; 一1) { //winphone手机                     alert(&quot;winphone 手机&quot;)；
}
}
〈/script&gt;
</code></pre><p>一百三十九、    如何调用原生的接口？<br>首先你得选择一个合适的框架作为自己的基础，以Dcloud为例，页面中一定要存在一个事件，plusready, plusready实际上是原生将桥接js注入到页面中的容器，进行任何方法 调用的时候都在plusready之后。所有api方法全部都托管在了一个plus对象中。使用语法 plus.模块名称.具体方法（参数，callback)<br>当我们需要打开系统相册的时候，可以这样做：<br>Gallery模块管理系统相册，支持从相册中选择图片或视频文件、保存图片或视频文 件到相册等功能。通过plus.gallery获取相册管理对象。打开相册plus.gallery.pick进行打开，选取多个图片{multiple:true,maximum:9,system:false}<br>一百四十、    微信支付怎么做？说说流程<br>1．申请微信公众号及支付功能申请：根据公众号申请流程申请即可。<br>2．获取商户支付配置信息及支付测试配置：<br>支付授权目录最多可以配置三个域名，测试授权目录只可以一个，这里需要 注意的是域名大小写必须要网站URL—致，否则会无法通过授权，提示支付请求的 URL不合法。另外，测试支付的微信号必须加到测试白名单，否则无法进行支付测 试。<br>3．H5页面发起支付请求，请求生成支付订单，获取用户授权（获取用户的openid)<br>4．调用统一下单API，生成预付单<br>5．生成JSAPI页面调用的支付参数并签名，注意时间戳timeStamp是32位字符串<br>6．返回支付参数prepay—id,paySign参数的html文本给前端。<br>7．微信浏览器自动调起支付JSAPI接口支付，提示用户输入密码。<br>8．确认支付，输入密码，提交支付。<br>9．步通知商户支付结果，商户收到通知返回确认信息。<br>10．返回支付结果，并发微信消息提示。<br>11．展示支付信息给用户，跳转到支付结果页面。<br>一百四十一、    混合开发的注意点<br>增强WebView : 原生WebView基本是PC平台浏览器内核的移植，但对于移动场景并不完全适合，各种硬件API得不到HTML5原生支持。因此对于WebView的种种Hack、增强应运而生，甚至出现了基于增强WebView提供第三方服务的。<br>路由：应用内跳转由于加入了 WebView而变得复杂起来，同时由于组件化、模块化带来的问 题，路由也成为人们讨论的重点。<br>缓存：移动网络条件差，为了用户体验，必须要做资源缓存和预加载。<br>通信：即HTML5和Native之间的通信。利用系统提供的桥接API可以实现，不过在应用上还 有着一些坑点和安全问题。<br>一百四十二、    说说你对手机平台的安装包后缀的理解<br>Android：<strong>apk<br>Ios：</strong>ipa<br>Windows：    wp7 wp8的是xap  wp8.1以后用8.1开发的是appx</p>
<p>NodeJS<br>一百四十三、    谈谈你对Socket编程的理解及实现原理，Socket 之间是怎么通讯的<br>A、Socket定义<br>Socket是进程通讯的一种方式，即调用这个网络库的一些API函数实现分布在不同主机的相 关进程之间的数据交换。几个定义：IP地址：即依照TCP/IP协议分配给本地主机的网络地 址，两个进程要通讯，任一进程首先要知道通讯对方的位置，即对方的IP。端口号：用来辨 别本地通讯进程，一个本地的进程在通讯时均会占用一个端口号，不同的进程端口号不同， 因此在通讯前必须要分配一个没有被访问的端口号。连接：指两个进程间的通讯链路。<br>B、实现原理<br>在TCP/IP网络应用中，通信的两个进程间相互作用的主要模式是客户/服务器（Client/ Server, C/S)模式，即客户向服务器发出服务请求，服务器接收到请求后，提供相应的服务。客户/服务器模式的建立基于以下两点：首先，建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而造就拥有众多资源的主机提供服务，资源较少的客 户请求服务这一非对等作用。其次，网间进程通信完全是异步的，相互通信的进程间既不存 在父子关系，又不共享内存缓冲区，因此需要一种机制为希望通信的进程间建立联系，为二 者的数据交换提供同步，这就是基于客户/服务器模式的TCP/IP。<br>C、通讯过程<br>服务器端：其过程是首先服务器方要先启动，并根据请求提供相应服务：（1)打开一通信 通道并告知本地主机，它愿意在某一公认地址上的某端□(如FTP的端口可能为21)接收客 户请求；（2)等待客户请求到达该端口； （3)接收到客户端的服务请求时，处理该请求并 发送应答信号。接收到并发服务请求，要激活一新进程来处理这个客户请求（如UNIX系统 中用fork、exec)。新进程处理此客户请求，并不需要对其它请求作出应答。服务完成后， 关闭此新进程与客户的通信链路，并终止。（4)返回第（2)步，等待另一客户请求。（5）关闭服务器客户端：（1)打开一通信通道，并连接到服务器所在主机的特定端口；(2)向服务器发服务请求报文，等待并接收应答；继续提出请求……（3)请求结束后关闭通信通道并终止。<br>从上面所描述过程可知：（1）客户与服务器进程的作用是非对称的，因 此代码不同。（2）服务器进程一般是先启动的。只要系统运行，该服务进程一直存在，直到正常或强迫终止。<br>详细参见：<br><a href="https://www.zhihu.com/question/29637351" target="_blank" rel="noopener">https://www.zhihu.com/question/29637351</a><br><a href="http://blog.csdn.net/panker2008/article/details/46502783?ref=myread" target="_blank" rel="noopener">http://blog.csdn.net/panker2008/article/details/46502783?ref=myread</a><br>一百四十四、    WEB应用从服务器主动推送Data到客户端有哪些方 式？<br>一般的服务器Push技术包括：<br>1)     基于AJAX的长轮询（long一polling)方式，服务器Hold—段时间后再返回信息；<br>2)    HTTP Streaming,通过iframe和〈script〉#签完成数据的传输；<br>3)    TCP长连接<br>4)    HTML5新引入的WebSocket，可以实现服务器主动发送数据至网页端，它和HTTP— 样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信， 意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应。<br>5)    nodejs的<a href="http://socket.io，它是websocket的一^^开源实现，对不支持websocket的浏" target="_blank" rel="noopener">http://socket.io，它是websocket的一^^开源实现，对不支持websocket的浏</a> 览器降级成comet / ajax轮询，<a href="http://socket.io的良好封装使代码编写非常容易。" target="_blank" rel="noopener">http://socket.io的良好封装使代码编写非常容易。</a><br>上述的 1 和2统称为comet技术。comet详细参考：<a href="http://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/</a> web/wa一lo一comet/<br>一百四十五、    简述Node.js的适用场景？<br>IIO 密集而非计算密集的情景；高并发微数据（比如账号系统）的情景。特别是高并发，Node.js 的性能随并发数量的提高而衰减的现象相比其他 server 都有很明显的优势。<br>Bad Use Cases<br>1．CPU heavy apps （高CPU消耗的app）<br>2．Simple CRUD / HTML apps （简单的CRUD / HTML apps）<br>3．NoSQL + Node.js + Buzzword Bullshit （NoSQL + Node.js + 各种扯淡的时髦词汇）<br>Good Use Cases<br>1．JSON API<br>2．Single page apps （单页面app）<br>3．Shelling out to unix tools （对unix工具的脚本化调用）<br>4．Streaming data （流数据）<br>5．Soft Realtime Applications （软件实时程序）<br>一百四十六、    什么是HTTPS，做什么用的呢？如何开启HTTPS?<br>1)    什么是HTTPS<br>https是http的加密版本，是在http请求的基础上，采用ssl进行加密传输。<br>2)    做什么用<br>加密数据，反劫持，SEO<br>3)    如何开启<br>生成私钥与证书，配置nginx,重启nginx看效果<br>详细参见：<a href="https://segmentfault.com/a/1190000006199237?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006199237?utm_source=tuicool&amp;utm_medium=referral</a><br>一百四十七、    你们原来公司如何发送的新消息推送?<br>（参考：）一般的服务器Push技术包括：<br>1．基于 AJAX 的长轮询（long一polling）方式，服务器Hold一段时间后再返回信息；<br>2．HTTP Streaming，通过iframe和<code>&lt;script&gt;</code>标签完成数据的传输；<br>3．TCP 长连接<br>4．HTML5新引入的WebSocket，可以实现服务器主动发送数据至网页端，它和HTTP一样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应<br>上述的1和2统称为comet技术，Comet：基于 HTTP 长连接的“服务器推”技术前些日子给项目网站加了后台通知的实时推送到前端显示，用的是nodejs的<a href="http://socket.io，它是websocket的一个开源实现，对不支持websocket的浏览器降级成comet" target="_blank" rel="noopener">http://socket.io，它是websocket的一个开源实现，对不支持websocket的浏览器降级成comet</a> / ajax 轮询，<a href="http://socket.io的良好封装使代码编写非常容易。" target="_blank" rel="noopener">http://socket.io的良好封装使代码编写非常容易。</a><br>一百四十八、    如何用NodeJS搭建中间层？<br>（如下图）  最上端是服务端，就是我们常说的后端。后端对于我们来说，就是一个接口的集合，服务端提供各种各样的接口供我们使用。因为有Node层，也不用局限是什么形式的服务。对于后端开发来说，他们只用关心业务代码的接口实现。<br>服务端下面是Node应用。<br>Node应用中有一层Model Proxy与服务端进行通讯。这一层主要目前是抹平我们对不同接口 的调用方式，封装一些view层需要的Model。</p>
<p>Node层还能轻松实现原来vmcommon,tms (引用淘宝内容管理系统）等需求。<br>Node层要使用什么框架由开发者自己决定。不过推荐使用express + xTemplate的组合， xTemplate能做到前后端公用。<br>怎么用Node大家自己决定，但是令人兴奋的是，我们终于可以使用Node轻松实现我们想要的输出方式 JSON/JSONP/RESTful/HTML/BigPipe/Comet/Socket/同步、异步，想怎么整就怎么整，完全根据你的场景决定。<br>浏览器层在我们这个架构中没有变化，也不希望因为引入Node改变你以前在浏览器中开发的认知。<br>引入Node，只是把本该就前端控制的部分交由前端掌控。<br>详细参见：<a href="http://blog.csdn.net/u011413061/article/details/50294263" target="_blank" rel="noopener">http://blog.csdn.net/u011413061/article/details/50294263</a><br>组件设计<br>一百四十九、    设计一个弹框组件，组件宽度为屏幕高度的50%， 宽度为屏幕宽度的80%，水平垂直居中。弹窗组件有 header, body, footer三部分，header中有标题，可定制，body区域，footer区域有确定和取消按钮，可定制两个按钮的文字内容，组件外的内容有遮罩，点击遮罩和取消按钮时关闭弹框，参照下图。（类似于layer的弹出层插件） </p>
<p>使用面向对象封装插件较为合适<br>构造函数的参数有header的标题及body内容和按钮文字内容<br>封装的方法应该有show, hide,在点击遮罩和取消按钮时调用hide方法<br>并且hide和show方法应该有返回值以供判断。<br>一百五十、    实现一个手势滑动轮播图组件。效果参考：<a href="https://static.xiaohongchun.com/goods/4514" target="_blank" rel="noopener">https://static.xiaohongchun.com/goods/4514</a> (请在手机里打开）</p>
<p>详细参考：<a href="http://www.jb51.net/article/65177.htm" target="_blank" rel="noopener">http://www.jb51.net/article/65177.htm</a><br>一百五十一、    设计基于观察者模式的事件绑定机制<br>观察者模式（发布-订阅模式）的定义：Observer的意图是定义对象之间的一种一（被观察者）对多（观察者） 的关系，当一个对象的状态发生改变时，所有依赖它的对象得到通知，并且会自动更新自己<br>在JavaScript中，一般使用事件模型来替代传统的观察者模式。<br>好处：<br>（1）可广泛应用于异步编程中，是一种替代传递回调函数的方案。<br>（2）可取代对象之间硬编码的通知机制，一个对象不用再显示地调用另外一个对象的某个接口。两对象轻松解耦。<br>代码参考：<a href="http://blog.csdn.net/phker/article/details/6880371" target="_blank" rel="noopener">http://blog.csdn.net/phker/article/details/6880371</a><br><a href="http://www.cnblogs.com/LuckyWi" target="_blank" rel="noopener">http://www.cnblogs.com/LuckyWi</a> nty/p/5796190.html<br>一百五十二、    jq自己扩展过什么插件？<br>弹出层插件、pagination插件、瀑布流插件、模态框插件等<br>参考：Jquery插件库    jquery之家<br>一百五十三、    侧滑菜单如何实现？<br>主要依靠两个大的容器来模拟侧滑菜单界面和主界面，把侧滑菜单放到页面右侧看不 到的地方，在操作的同时，使用css3过渡、动画或者jq来使两个容器相对运动，实现侧滑菜单效果<br>参考：<a href="http://www.111cn.net/wy/js一ajax/99687.htm" target="_blank" rel="noopener">http://www.111cn.net/wy/js一ajax/99687.htm</a><br>一百五十四、    权限管理如何实现？<br>（1）前端控制：<br>　　前端的控制比较简单，从后台获取到用户的权限之后，可以存在session或者cookie中，然后在页面加载的时候，通过session或者cookie中存的权限来选择让该功能展现或者禁用。<br>前端实现代码详细参见：<a href="http://blog.csdn.net/liuweidagege/article/details/42497731" target="_blank" rel="noopener">http://blog.csdn.net/liuweidagege/article/details/42497731</a><br>（2）后台控制：<br>　　仅仅依靠前端的控制是无法完美解决权限控制的问题，因为前端页面的加载过程是在浏览器中完成的，用户可以自行篡改页面；或者用户可以直接通过URI请求来获取非法权限功能。所以需要在后台实现权限控制。<br>　　后台的控制方法也很多，比如filter、spring的AOP等。在此选用springMVC的interceptor来控制。<br>（3）全局异常管理：<br>　　思路是在拦截器中权限校验失败时，抛出一个权限校验失败的异常，然后通过全局异常管理类来捕获并返回前端特定的格式。具体如下。<br>一百五十五、    —个大数组，可能存了 100万个数字，要从其中取出 来第二大的数的下标，有什么快速的方法？<br>用两个变量max，max2，其中max储存最大值，max2储存第二大值；初始化的时候，将数组中的第一个元素中较大的存进max中，较小的存进max2中，然后从第三个元素(下标为2)的元素开始，如果遇到的数比max大，就让max2=max;max等于遇到的数一直循环，直到数组尾部，最后输出max2<br>单元测试<br>一百五十六、    单个组件怎么测试性能<br>React组件测试框架用mocha,测试库用官方的测试工具库，也可使用第三方库Enzyme,建议使用第三方的。<br>详细参见：<a href="http://www.ruanyifeng.com/blog/2016/02/react一testing一tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/02/react一testing一tutorial.html</a><br>Vue使用Unit和e2e测试工具：<br>详细参见：<a href="http://www.tuicool.com/articles/6vulNvR" target="_blank" rel="noopener">http://www.tuicool.com/articles/6vulNvR</a><br>React<br>一百五十七、    有了解过React.js吗？<br>React.js 只是一个视图库<br>　　（1）声明式设计<br>　　（2）高效：通过对DOM的模拟，最大限度的减少与DOM的交互。<br>　　（3）灵活：可以与已知的框架或库很好的配合。<br>　　（4）JSX：是js语法的扩展，不一定使用，但建议用。<br>　　（5）组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中。<br>　　（6）单向响应的数据流：React实现了单向响应的数据流，从而减少了重复代码，这也是解释了它为什么比传统数据绑定更简单。<br>一百五十八、    redux中间件<br>中间件提供第三方插件的模式，自定义拦截action一&gt; reducer的过程。变为action一〉 middlewares 一&gt; reducer。这种机制可以让我们改变数据流，实现如异步action， action过滤，日志输出，异常报告等功能。<br>常见的中间件：<br>redux一logger:提供日志输出<br>redux一thunk:处理异步操作<br>redux一promise:处理异步操作，actionCreator的返回值是promise<br>一百五十九、    redux有什么缺点<br>1．一个组件所需要的数据，必须甶父组件传过来，而不能像flux中直接从store取。<br>2．当一个组件相关数据更新吋，即使父组件不需要用到这个组件，父组件还是会重新render,可能会 有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。<br>一百六十、    react组件的划分业务组件技术组件？<br>根据组件的职责通常把组件分为UI组件和容器组件。<br>UI组件负责UI的呈现，容器组件负责管理数据和逻辑。<br>两者通过React一Redux提供connect方法联系起来。<br>具体使用可以参照如下链接：<br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react一redux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react一redux.html</a></p>
<p>一百六十一、    react生命周期函数<br>这个问题要考察的是组件的生命周期<br>一、    初始化阶段：<br>getDefaultProps:获取实例的默认属性<br>getInitialState:获取每个实例的初始化状态<br>componentWillMount:组件即将被装载、渲染到页面上<br>render:组件在这里生成虚拟的DOM节点<br>componentDidMount:组件真正在被装载之后<br>二、    运行中状态：<br>componentWillReceiveProps:组件将要接收到属性的时候调用<br>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回false,接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）<br>componentWillUpdate:组件即将更新不能修改属性和状态<br>render:组件重新描绘<br>componentDidUpdate:组件已经更新<br>三、    销毁阶段：<br>compcomponentWillUnmount:组件即将销毁<br>一百六十二、    react性能优化是哪个周期函数？<br>shouldComponentUpdate这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能。<br>详细参考：<a href="https://segmentfault.com/a/1190000006254212" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006254212</a><br>一百六十三、    为什么虚拟dom会提高性能？<br>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提髙性能。<br>具体实现步骤如下：<br>1． 用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中<br>2．当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异<br>3．把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。<br>参考链接：<a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/29504639?sort=created</a><br>一百六十四、    diff 算法？<br>1)    把树形结构按照层级分解，只比较同级元素。<br>2)    给列表结构的每个单元添加唯_的key属性，方便比较。<br>3)    React只会匹配相同class的component (这里面的class指的是组件的名字）<br>4)    合并操作，调用component的setState方法的时候,React将其标记为dirty.到每一个事件循环 结束,React检查所有标记dirty的component重新绘制.<br>5)    选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。<br>参考链接：<a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000606216</a><br>一百六十五、    react性能优化方案<br>1)    重写shouldComponentUpdate来避免不必要的dom操作0<br>2)    使用 production 版本的react.js0<br>3)    使用key来帮助React识别列表中所有子组件的最小变化。<br>参考链接：<br><a href="https://segmentfault.com/a/1190000006254212" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006254212</a> <a href="http://blog.csdn.net/limm33/article/details/50948869" target="_blank" rel="noopener">http://blog.csdn.net/limm33/article/details/50948869</a><br>一百六十六、    简述flux思想<br>Flux的最大特点，就是数据的”单向流动”。<br>1．用户访问View<br>2．View发出用户的Action<br>3．Dispatcher收到Action,要求Store进行相应的更新<br>4．Store更新后，发出一个”change”事件<br>5．View收到”change”事件后，更新页面<br>参考链接：<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/flux.html</a><br>一百六十七、    React项目用过什么脚手架？ Mern? Yeoman?<br>Mern: MERN是脚手架的工具，它可以很容易地使用Mongo, Express, React and NodeJS生成<br>同构JS应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。<br>参考链接：<a href="http://www.open一open.com/lib/view/open1455953055292.html" target="_blank" rel="noopener">http://www.open一open.com/lib/view/open1455953055292.html</a><br>Vue.js<br>一百六十八、    vue与react的对比，如何选型？从性能，生态圈，数据量，数据的传递上，作比较<br>1)    React和Vue有许多相似之处，它们都有：<br>使用 Virtual DOM<br>提供了响应式（Reactive)和组件化（Composable)的视图组件。<br>将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。<br>2)    性能：<br>到目前为止，针对现实情况的测试中，Vue的性能是优于React的。<br>3)    生态圈<br>Vue.js: ES6+Webpack+unit/e2e+Vue+vue一router+单文件组件+vuex+iVew<br>React: ES6+Webpack+Enzyme+React+React一router+Redux<br>4)    什么时候选择Vue.js<br>如果你喜欢用（或希望能够用）模板搭建应用，请使用Vue<br>如果你喜欢简单和”能用就行”的东西，请使用Vue<br>如果你的应用需要尽可能的小和快，请使用Vue<br>如果你计划构建一个大型应用程序，请使用React<br>如果你想要一个同时适用于Web端和原生App的框架，请选择React<br>如果你想要最大的生态圈，请使用React<br>详细参考：<br><a href="http://cn.vuejs.org/v2/guide/comparison.html#React" target="_blank" rel="noopener">http://cn.vuejs.org/v2/guide/comparison.html#React</a><br><a href="http://blog.csdn.net/yzh_2017/article/details/54909166" target="_blank" rel="noopener">http://blog.csdn.net/yzh_2017/article/details/54909166</a><br>一百六十九、    vue slot是做什么的？<br>简单来说，假如父组件需要在子组件内放一些D〇M，那么这些DOM是显示、不显示、在哪 个地方显示、如何显示，就是slot分发负责的活。<br>详细参考：<a href="http://cn.vueis.orq/v2/quide/comp〇nents.html#使用一Slot一分发内容" target="_blank" rel="noopener">http://cn.vueis.orq/v2/quide/comp〇nents.html#使用一Slot一分发内容</a><br>一百七十、    vue和angular的优缺点以及适用场合？<br>参见：《在选择框架的时候要从哪方面入手》一题<br>一百七十一、    vue路甶实现原理？<br>以官方仓库下examples/basic基础例子来一点点具体分析整个流程。<br>和流程相关的主要需要关注点的就是components、history目录以及create一matcher.js、 create一route一map.js、index.js，install.js。<br>从入口，作为插件，实例化VueRouter,实例化History,实例化Vue, defineReactive定 义_route, router一link和router一view组件等几个方面展开分析<br>必须参见：<a href="http://www.tuicool.com/articles/jQRnlrF" target="_blank" rel="noopener">http://www.tuicool.com/articles/jQRnlrF</a><br>一百七十二、    你们vue项目是打包了一个js文件，一个css文件， 还是有多个文件？<br>根据vue一cli脚手架规范，一个js文件，一个CSS文件。<br>详细参见：<br><a href="http://blog.csdn.net/lx376693576/article/details/54911340" target="_blank" rel="noopener">http://blog.csdn.net/lx376693576/article/details/54911340</a><br><a href="https://zhuanlan.zhihu.com/p/24322005" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24322005</a><br>一百七十三、    vue遇到的坑，如何解决的？<br>Vue1.0升级2.0有很多坑:生命周期；路由中引入静态js，全局组件，全局变量，全局 function; v一for循环的key, value值互换了位置，还有track一by; filter过滤器；遍历数组时， key值不能做model;父子通信等。<br>其他坑详见：<br><a href="http://blog.csdn.net/lemon_zhao/article/details/55510589" target="_blank" rel="noopener">http://blog.csdn.net/lemon_zhao/article/details/55510589</a> <a href="https://segmentfault.com/a/1190000008347498" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008347498</a> <a href="http://www.tuicool.com/articles/aUrmumV" target="_blank" rel="noopener">http://www.tuicool.com/articles/aUrmumV</a><br>一百七十四、    vue的双向绑定的原理，和angular的对比<br>在不同的MWM框架中，实现双向数据绑定的技术有所不同。<br>AngulaJS采用‘‘脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进 行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改 变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视 图，更新页面展现。如果是手动对ViewModel的数据进行变更，为确保变更同步到视图， 需要手动触发一次‘‘脏值检测”。<br>VueJS则使用ES5提供的〇bject.defineProperty()方法，监控对数据的操作，从而可以自 动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的 视图，而不是对所有的数据都执行一次检测。<br>详细参见：<a href="http://www.jianshu.eom/p/d3a15a1f94a0" target="_blank" rel="noopener">http://www.jianshu.eom/p/d3a15a1f94a0</a><br>一百七十五、    vue一cli，脚手架<br>安装：$ npm instaH 一g vue一cli<br>使用：$ vue init <code>&lt;template一name&gt; &lt;project一name&gt;</code><br>webpack配置详解：<a href="https://zhuanlan.zhihu.eom/p/24322005" target="_blank" rel="noopener">https://zhuanlan.zhihu.eom/p/24322005</a><br>一百七十六、    Vue里面router一link在电脑上有用，在安卓上没反应 怎么解决？<br>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决。<br>框架底层<br>一百七十七、    j〇uery源码中值得借鉴的？<br>使用模块化思想，模块间保持独立，不会导致多个开发人员合作时产生的冲突。<br>1．在设计程序时，要结构清晰，髙内聚，低耦合。<br>2．利用多态的方式，实现方法的重载，提髙代码的复用率<br>3．jQuery的链式调用以及回溯<br>4．jQuery.fn.extend与;jQuery.extend方法来实现扩展静态方法或实例方法<br>一百七十八、    $.ready是怎么实现的？<br>原生js中window.onload事件是在页面所有的资源都加载完毕后触发的.如果页面上有大图片等资源响应缓慢，会导致window.onload事件迟迟无法触发.所以出现了 DOM Ready事件.此事件在D0M文档结构准备完毕后触发，即在资源加载前触发.<br>jQuery中的ready方法实现了当页面加载完成后才执行的效果，但他并不是window.onload或者doucment.onload的封装，而是使用标准W3C浏览器DOM隐藏api和旧浏览器缺陷来完成的。可以通过阅读jq源码来理解：<br>DOMContentLoaded = function(){<br>     //取消事件监听，执行ready方法<br>    if ( document.addEventListener ){<br>        document.removeEventListener( “DOMContentLoaded”,<br>    DOMContentLoaded, false );<br>        jQuery.ready();<br>    }else if ( document.readyState === “complete” ) {<br>        document.detachEvent( “onreadystatechange”, DOMContentLoaded );<br>        jQuery.ready();<br>    }<br>};<br>在 jQuery 中完整的代码如下所示。<br>jQuery.ready.promise = function( obj ) {<br>    if ( !readyList ) {<br>        readyList = jQuery.Deferred();<br>            //表示页面已经加载完成，直接调用 ready方法<br>        if ( document.readyState === “complete” ) {<br>            //将 jQuery.ready压入异步消息队列，设置延迟时间1毫秒（注意，有些浏览器延迟不能小于4毫秒）<br>            setTimeout( jQuery.ready);<br>        }<br>        else if ( document.addEventListener ) //<br>        {<br>             //监听DOM加载完成<br>            document.addEventListener( “DOMContentLoaded”, DOMContentLoaded, false );<br>             //这里是为了确保所有ready执行结束，如果DOMContentLoaded方法执行了，将有一个状态值 isReady被设置为true,因此，<br>             //ready方法一旦执行，那么将只执行一次，window.addEventListener中的ready 将被 return 中断<br>            window.addEventListener( “load”, jQuery.ready, false );<br>        } else {<br>            //低版本的IE浏览器<br>            document.attachEvent( “onreadystatechange”, DOMContentLoaded );<br>            window.attachEvent( “onload”, jQuery.ready );<br>            var top = false;<br>            try {<br>                top = window.frameElement == null &amp;&amp; document.documentElement;<br>            } catch(e) {<br>            }<br>            if ( top &amp;&amp; top.doScroll )  //剔除iframe的成分<br>            {<br>                (function doScrollCheck() {<br>                    if ( !jQuery.isReady ) {</p>
<pre><code>                    try {
                        //根据bug来兼容低版本的IE http://javascript.nwbox.com/IEContentLoaded/
                        top.doScroll(&quot;left&quot;);
                    } catch(e) {
                        //由于低版本的IE 浏览器，onreadystatechange事件不可靠，因此需要根据各个bug来判断页面是否已加载完成
                        return setTimeout( doScrollCheck, 50 ); 
                    }
                    jQuery.ready();
                }
            })();
        }
    }
}
</code></pre><p>return readyList.promise( obj );<br>};<br>需要的时候，在我们调用 ready 函数的时候，才需要注册这些判断页面是否完全加载的处理，如下所示：<br>ready: function( wait ){<br>    if ( wait === true ? 一一jQuery.readyWait : jQuery.isReady ) {<br>        //判断页面是否已完成加载并且是否已经执行ready方法<br>        return;<br>    }<br>    if ( !document.body ) {<br>        return setTimeout( jQuery.ready );<br>    }<br>    jQuery.isReady = true; //指示ready方法已被执行<br>    if ( wait !== true &amp;&amp; 一一jQuery.readyWait &gt; 0 ) {<br>        return;<br>    }<br>    readyList.resolveWith( document, [ jQuery ] );<br>    if ( jQuery.fn.trigger ) {<br>        jQuery( document ).trigger(“ready”).off(“ready”);<br>    }<br>}<br>总结：<br> 页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页 面包含图片等文件在内的所有元素都加载完成。(可以说：ready 在onload 前加载！！！)<br>一般样式控制的，比如图片大小控制放在onload 里面加载;<br>jS事件触发的方法，可以在ready 里面加载;<br>一百七十九、    懒加载的实现原理?<br>意义：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br>实现原理：先加载一部分数据，当触发某个条件时利用异步加载剩余的数据，新得到的数据 不会影响原有数据的显示，同时最大程度上减少服务器端的资源耗用。<br>实现方式：</p>
<ol>
<li>第一种是纯粹的延迟加载，使用setTimeOut或setlnterval进行加载延迟.</li>
<li>第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</li>
<li>第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片。</li>
</ol>
<p>一百八十、    双向数据绑定和单向数据的区别？<br>1．单向数据流中，父组件给子组件传递数据，但反过来不可以传递，也就是说单向数据流是从最外层节点传递到子节点，他们只需从最外层节点获取props渲染即可，如果顶层组件的 某个prop改变了，React会递归的向下便利整棵组件树，重新渲染所有使用这个属性的组件， React组件内部还具有自己的状态，这些状态只能在组件内修改；双向数据绑定是数据与视图 双向绑定，数据发生改变时，视图也改变，视图发生改变时，数据也会发生改变。<br>2．双向数据绑定的各种数据相互依赖相互绑定，导致数据问题的源头难以被跟踪到；单向 数据流的数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷，缺点是写起来不太方便，要使视图发生改变就得创建各种action来维护state。<br>3．双向绑定把数据变更的操作隐藏在框架内部，调用者并不会直接感知。而在践行单向数 据流的flux系的实现中，其实不过是在全局搞了一个单例的事件分发器（dispatcher)，开发者 必须显式地通过这个统一的事件机制做数据变更通知。<br>一百八十一、    怎么实现一个类似于const功能的方法？<br>es6中const相当于声明常量不可更改，我们利用defineProperty可以模拟实现；我们把 writable设置为false的时候，该属性就成了只读，也就满足了常量了性质，我们把常量封装 在CONST命名空间里面，但是因为我们依然可以通过修改属性writable为true修改属性值，所以 configurable设置为false,不能修改属性；<br>模拟：<br>如下代码CONST.a相当于es6中cont a=2; CONST.a是不可以更改的常量； </p>
<pre><code>var CONST = { };
Object.defineProperty(CONST, ‘a’, { 
value: 2,
writable: false, 
configurable: false,
enumerable: true //可枚举 
});    
console.log(CONST.a);    //2
CONST.a = 3;
console.log(CONST.a);    //2
</code></pre><p>一百八十二、    使用原生js模拟一个apply方法<br>apply方法：<br>语法：apply([thisObj[,argArray]])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<pre><code>Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;
    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&#39;arr[&#39; + i + &#39;]&#39;);
        }
        result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
    }
    delete context.fn
    return result;
}
</code></pre><p>一百八十三、    使用原生js模拟一个call方法<br>call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<pre><code>Function.prototype.call = function (context) {
    var context = context || window;
    context.fn = this;
    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&#39;arguments[&#39; + i + &#39;]&#39;);
    }
    var result = eval(&#39;context.fn(&#39; + args +&#39;)&#39;);
    delete context.fn
    return result;
}
</code></pre><p>以上两个方法的具体实现原理可以参考：<a href="https://juejin.im/post/5907eb99570c3500582ca23c" target="_blank" rel="noopener">https://juejin.im/post/5907eb99570c3500582ca23c</a><br>一百八十四、    Object.create()和直接创建对象有什么区别？<br>Object.create()方法创建一个拥有指定原型和若干个指定属性的对象 //Object.create(proto,[propertiesObject])<br>该方法创建一个对象，其接受两个参数，第一个参数是这个对象的原型对象proto,<br>第二个是一个可选参数，用以对对象的属性做进一步描述<br>如果proto参数不是null或一个对象值，则抛出一个TypeError异常 </p>
<pre><code>var objl = Object.create({
 x: 1, 
 y: 2
}); //对象obj1继承了属性x和y
var obj2 = Object.create(null);//对象 obj2 没有原型
</code></pre><p>对象字面量是创建对象最简单的一种形式，<br>目的是在于简化创建包含大量属性的对象的过程。<br>对象字面量由若干属性名(keys)和属性值(values)成对组成的映射表，<br>key和value中间使用冒号(:)分隔，<br>每对key/value之间使用逗号(,)分隔，<br>整个映射表用花括号({})括起来。<br>在用字面量来创建对象的时候，对象中的property定义可以用单引号或双引号来包括，也可以忽略引号。不过，当property中出现空格、斜杠等特殊字符，或者使用的property与JS关键词冲突时，则必须使用引号。<br>var obj = {<br>property_1: value_1,// property—# 可能是一个标识符…<br>2: value_2, //或者是一个数字 “property n”: value_n // 或是一个字符串<br>}<br>通过对象字面量创建的对象复用性较差，<br>使用Object.create()创建对象时不需要定义一个构造函数就允许你在对象中选择其原型对象。<br>一百八十五、    使用for in遍历对象和使用Object.keys来遍历对象 有什么区别？<br>1．for in主要用于遍历对象的可枚举属性，包括自有属性、继承自原型的属性<br>2．Object.keys返回一个数组，元素均为对象自有的可枚举属性<br>3．Object.getOwnProperty 用于返回对象的自有属性，包括可枚举的和不可枚举的 </p>
<pre><code>var obj = {
&quot;name&quot;:&quot;xiaosan&quot;,
&quot;age&quot;:23
}
Object.defineProperty(obj,&quot;height&quot;,{value:178,enumerable:false})
Object.prototype.prototypel = function(){
console.log(&#39;aaa&#39;)
}
Object.prototype.prototype2 = &#39;bbb&#39;;
//for in
for(var i in obj){
console.log(i); //name age prototypel prototype2 
}
//Object.keys
console.log(Object.keys(obj)) //name age
//Object.getOwnProperty
console.log(Object.getOwnPropertyNames(obj)) //name age height
</code></pre><p>一百八十六、    深拷贝和浅拷贝以及应用场景</p>
<p>i.浅拷贝</p>
<pre><code>//拷贝就是把父对象的属性，全部拷贝给子对象。
var Chinese = { 
nation:&#39;中国’
}
Var Doctor={
career:&#39;医生&#39;
}
function extendCopy(p) { 
var c = {}; 
for (var i in p) { 
c[i] = p[i];
}
c.uber = p; return c;
}
</code></pre><pre><code>//使用的时候，这样写：
Doctor = extendCopy(Chinese);
Doctor.career =&#39;医生&#39;； 
alert(Doctor.nation); // 中国
//但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。
//请看，现在给Chinese添加一个&quot;出生地&quot;属性，它的值是一个数组。
Chinese.birthPlaces =[&#39;北京&#39;,&#39;上海&#39;,&#39;香港&#39;];
//通过extendCopy()函数，Doctor继承了Chinese。
Doctor = extendCopy(Chinese);
//然后，我们为Doctor的&quot;出生地&quot;添加一个城市：
Doctor.birthPlaces.push(&#39;厦门&#39;)；
//看一下输入结果
alert(Doctor.birthPlaces); //北京，上海，香港，厦门 alert(Chinese.birthPlaces); //北京，上海，香港，厦门
//结果是两个的出生地都被改了。
//所以，extendCopy()只是拷贝了基本类型的数据，我们把这种拷贝叫做&#39;&#39;浅拷贝〃。
</code></pre><p>2.深拷贝</p>
<pre><code>//所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难， 只要递归调用&quot;浅拷贝&quot;就行了。

var Chinese = {
nation:&#39;中国’
}
var Doctor = { 
career:&#39;医生&#39;
}
function deepCopy(p, c) { 
var c = c || {}; 
for (var i in p) {
if (typeof p[i] === &#39;object&#39;) {
c[i] = (p[i].constructor === Array) ? [] : {}; deepCopy(p[i], c[i]);
} else {
c[i] = p[i];
}
}
return c;
}

//看一下使用方法：
Doctor = deepCopy(Chinese);
//现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：
Chinese.birthPlaces =[&#39;北京&#39;,&#39;上海&#39;,&#39;香港&#39;];
Doctor.birthPlaces.push(&#39;厦门&#39;)； 
alert(Doctor.birthPlaces); //北京，上海，香港，厦门
alert(Chinese.birthPlaces); //北京，上海，香港
</code></pre><p>JavaScript中的对象一般是可变的（Mutable),因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如’foo={a: 1}; bar=foo; bar.a=2’你会发现此时 ‘foo.a’也被改成了 ‘2’。<br>虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用shallowCopy (浅拷贝）或deepCopy (深拷贝）来避免被修改，但这样做造成了CPU和内存的浪费。<br>Immutable可以很好地解决这些问题。<br>一百八十七、    原型链，闭包与继承<br>闭包的好处：<br>1．不会污染全局环境；<br>2．可以进行形参的记忆，减少形参的个数,延长形参生命周期； </p>
<pre><code>function add(x) {
return function(y) { 
return (x+y);
}
}
var sum = add(2); 
sum(5);//结果为 7
3．方便进行模块化开发； 
var module = (function() { 
var name = &#39;123&#39;; 
function init() {
console.log(name);
}
return {
getname:init
}
})()
module.getname();//结果为 123;
</code></pre><p>继承：一个构造函数继承另一个构造函数中的方法;可以省去大量的重复。</p>
<pre><code>function Man(name,age) { 
this.name = name; this.age = age;
}
var person = new Man(&#39;tom&#39;,19); 
function Woman(name,age) { 
this.sex = &#39;woman&#39;;
Man.call(this,name,age);
}
Woman.prototype = Man.prototype; 
var person1 = new Woman(&#39;july&#39;,20); 
person1.name//结果为 july 
person1.age //结果为 20 
person1.sex //结果为 woman
</code></pre><p>原型链查找：进行方法调用的时候，会先在实例自身上找，如果没有就去该实例的原型上找。</p>
<pre><code>function People() { 
this.name = &#39;a People&#39;;
}
People.prototype.say = function() { 
this.age = &#39;10&#39;;
console.log(this.name,this.age);
}
var person = new People(); 
person.say();
</code></pre><p>AngularJS<br>一百八十八、    说说你对MVC和MVVM的理解<br>mvc:<br>View 传送指令到 Controller<br>Controller 完成业务逻辑后，要求 Model 改变状态<br>Model 将新的数据发送到 View，用户得到反馈<br>所有通信都是单向的。<br>Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。<br>组成部分Model、View、ViewModel<br>View：UI界面<br>ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；<br>Model：数据访问层<br>一百八十九、    对 bootstrap 的掌握？为什么用 angular+bootstrap 搭建后台管理系统<br>bootstrap是一个快速开发的响应式框架，主要是为了快速搭建ui界面，bootstrap 的web组件和js插件对pc端开发比较友好，尤其是栅格化系统可以良好兼容浏览器， 低版本浏览器可以使用bootstrap一responsive的插件兼容，js插件有各种回调机制，可以满足自己的多样开发需求，而且bootstrap使用css属性来操作样式，免去了手写原生代码的痛苦，使用angular进行数据绑定，bootstrap来搭建界面，提升开发效率<br>个人心得：<br>我在实际开发中使用ace admin这套基于boostrap的框架，可以更快速的开发，数据项通过json结构进行配置，几乎不用手写代码，提升开发效率<br>一百九十、    angular中ng一if和ng-show/hide 有什么区别？<br>1．ng一if 在后面表达式为 true 的时候才创建这个 dom 节点，ng一show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。<br>2．ng一if 会（隐式地）产生新作用域，ng一switch .ng一include 等会动态创建一块界面的也是如此。<br>个人心得：<br>ng一if添加删除节点，那么肯定回创建作用域，而ng一show/hide则不会<br>一百九十一、    Angular中ng一click中写的表达式，可以用js原生上 的方法吗？为什么？<br> ng一click和原生事件完成的功能是一样的，但是ng一click做了优化，而且ng一click里面可以写表达式，运算过程，click则要单独处理，手写功能。<br>个人心得：<br>如果不在作用域里添加函数，可以配合ng一init初始化属性值，在ng一click里添加算 法或者某一功能，虽然ng一inK不推荐使用，但是侧面说明ng一click的优势<br>一百九十二、    内置filter都有哪些？<br>ng 内置的 filter 有九种：<br>date（日期）<br>currency（货币）<br>limitTo（限制数组或字符串长度）<br>orderBy（排序）<br>lowercase（小写）<br>uppercase（大写）<br>number（格式化数字，加上千位分隔符，并接收参数限定小数点位数）<br>json（格式化 json 对象）<br>filter（处理一个数组，过滤出含有某个子串的元素）<br>filter有两种使用方法，一种是直接在页面里：</p>
<pre><code>&lt;p&gt;{{now | date : 'yyyy一MM一dd'}}&lt;/p&gt;
</code></pre><p>另一种是在 js 里面用：<br>// $filter(‘过滤器名称’)(需要过滤的对象, 参数1, 参数2,…)<br>$filter(‘date’)(now, ‘yyyy一MM一dd hh:mm:ss’);<br>一百九十三、    如何自定义filter?<br>在模块下挂在一个filter()方法，第一个参数传入过滤器的名字，第二个参数是回调函数，处理过滤方法的详细内容，最后返回结果，这样外部就可以根据过滤器的名字调用了<br>例如</p>
<pre><code>myAppModule.filter(&quot;reverse&quot;，function(){ 
return  function(input,uppercase){ 
var out =&quot;&quot;;
for(var i=0 ; i&lt;input.length; i++){ 
out = input.charAt(i)+out;
}
if(uppercase){ 
out = out.toUpperCase();
}
return out;
}
});
</code></pre><p>使用：name丨reverse通过管道符调用<br>一百九十四、    factory、service 和 provider 是什么关系？<br>factory , service , provider都是angular 提供的服务<br>factory就是原生js里的方法，一个简单的函数<br>service类似原生里构造函数的过程，拥有一个构造器constructor，也就是说有 new的过程，追加属性和方法都是在this上追加的<br>provider是服务商当service需要配置的时候，需要使用provider提供服务，例如当使用angular进行跨域访问，需要配置jsonp信息的时候，就可以使用provider进行config的配置，简单理解是service的高级版本，provider提供一个$get的属性来返回 $provider的实例<br>他们都是单例模式，只实例化一次<br>个人理解 ：<br>provider &gt; service &gt; factory<br>  factory用来配置简单的服务<br>service是在factory的基础之上加入了面向对象的思想，提供更多功能的服务<br>provider是在service的基础上进一步改进配置信息<br>factory与service在底层代码上都来源于provider<br>例子介绍：<br>我可以在factory里写一个$http( )请求，不做任何配置，参数写死<br>我可以在service里写一个$http( )请求，传入请求的参数可以先配置在this的属性上传入方法<br>我可以在provider里写一个请求，然后在config上传入要配置的参数，URL， method，data等信息，通过config来修改provider的参数，再将服务商提供的服务注入控制器controller<br>注意事项：<br>config里传入的参数是nameProvider而不是name，也就是说你的叫做 myProvider, config 里传入的参数就是myProviderProvider而不是myProvider<br>一百九十五、    angular的数据绑定采用什么机制？详述原理<br>通过$watch来监听每一次dom的变化，然后$digest来遍历循环所有的$watch 队列，发现与原来不同的值，也就是脏值则进行修改，最后通知$apply , $apply会进入angular context的执行环境，通知浏览器拿回控制权，修改相应的dom节点<br>个人心得：<br>每一个ng指令的触发都在内部触发了一个$Watch的队列，加入一组标签 </p>
<pre><code>&lt;li ng一repeat=&quot;item in items&quot;&gt;
{{ item }}
&lt;/li&gt;
</code></pre><p>循环了 10次，那么就触发了10个item与1个ng一repeat的11个$watch的队列，<br>$digest会遍历循环这些队列，比较值的变化，有变化的即为脏值过程叫做dirty一checking，$digest修改完对应的值就会通知$apply()准备进入angular context的执行阶段修改dom，没有变化则不修改。也就是说我们在页面每次触发的操作，每次输入一个文字都会触发$watch，可见于react相比angular的劣势出现了<br>一百九十六、    两个平级界面块a和b，如果a中触发一个事件，有哪些方式能让b知道？详述原理<br>1．通过a的子controller将事件使用$emit传递给父controller再将事件用 $broadcast传递给b controller实现数据传递<br>2．也可以通过service服务，将数据保存在service之内，然后在b中调用service<br>个人心得：<br>像这种数据传递的方式其实有很多种，本质是不同作用于之间的数据传递，只要 掌握住这一点思想有很多方式解决，比如我可以尝试挂在$rootScope之上进行共 享，也可以用本地存储来存储数据，实现数据共享。方法不重要，关键是如何解决的思路。<br>一百九十七、    —个angular应用应当如何良好地分层？<br>目录结构的划分<br>对于小型项目，可以按照文件类型组织，比如：<br>css<br>js<br>controllers<br>models<br>services<br>filters<br>templates<br>但是对于规模较大的项目，最好按业务模块划分，比如：<br>css<br>modules<br>account<br>controllers<br>models<br>services<br>filters<br>templates<br>disk<br>controllers<br>models<br>services<br>filters<br>templates<br>modules下最好再有一个common目录来存放公共的东西<br>一百九十八、    angular应用常用哪些路甶库，各自的区别是什 么？<br>ng一router，ui一touter，ui一router可以嵌套子视图<br>一百九十九、    如果通过angular的directive规划一套全组件化体 系，可能遇到哪些挑战？<br>隔离作用域，ng一指令的作用域传递<br>二百、    分属不同团队进行开发的angular应用，如果要做整合，可能会遇到哪些问题，如何解决？<br>可能会遇到不同模块之间的冲突。比如一个团队所有的开发在moduleA下进行， 另一团队开发的代码在moduleB下<br>angular.module(‘myApp.moduleA’，[ ])<br>.factory(‘serviceA’, function(){<br>…….<br>})<br>angular.module(‘myApp.moduleB’，[ ])<br>.factory(‘serviceA’，function(){<br>……<br>})<br>angular.module(‘myApp’，[‘myApp.moduleA’，’myApp.moduleB’])<br>会导致两个module下面的serviceA发生了覆盖。<br>个人心得：没有太好的解决方案，只能约定命名规范<br>二百〇一、    angular的缺点有哪些？<br>不适合做交互过多的项目，因为没有选择器的存在，<br>导致学习成本较高，对前端不友好。但遵守AngularJS的约定时，生产力会很高，对Java程序员友好<br>因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取<br>二百〇二、    如何看待angularl.2中引入的controller as语 法？<br>为angular添加this作用域链，使得angular更加像原声写法<br>二百〇三、    详述angular的“依赖注入”。<br>依赖注入是一个在组件中给出的替代了硬的组件内的编码它们的依赖关系的软件设计模式。这减轻一个组成部分，从定位的依赖，依赖配置。这有助于使组件可重用，维护和测试。<br>AngularJS提供了一个至高无上的依赖注入机制。它提供了一个可注入彼此依赖 constant value factory service provide 核心组件。<br>二百〇四、    当你简单的动态给页面插入html时，此时html带有 angular的语法不会执行的，为什么？<br>通过$compile进行处理，任何指令的生效都需要compile，这一步在app启动的时候angular先帮你做了，但你插入的html是没有经过compile这个步骤的，所以你手动 compile下即可。<br>二百〇五、    使用ng一repeat出错：Error: [ngRepeat:dupes]，怎么回事？<br>Error: [ngRepeat:dupes]这个出错提示具体意思是指数组中有2个以上的相同数字。 ngRepeat不允许collection中存在两个相同Id的对象<br>对于数字对象来说，它的id就是它自身的值，因此，数组中是不允许存在两个相同的数字的。为了规避这个错误，需要定义自己的track by表达式。<br>例如：在ng一repeat=”itme in items “中加入rack by item.id 或者track by fnCustomld(item)。 嫌麻烦的话，直接拿循环的索引变量$index来用item in items track by $index——&gt;ng一repeat=”itme in items track by $index”<br>一句话总结：因为angular不允许数组中出现重复的值，所以会报错dupes错误，意思是重复的参数错误<br>二百〇六、    Ng一repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？<br>见上题<br>二百〇七、    使用第三方插件或者原生的js修改angular中的 model或者view的值时，相应的model或者view的值 不会变化，也就是angular的双向数据绑定失效，怎么回事？<br>angular有自己的一个上下文，所有与angular有关的代码执行（如双向数据绑定）都在这个上下文中进行，因此如果你用第三方插件或者原生的js进行操作时，此时代码是在javascript的上下文中执行，angular无法知道你是否修改model或者view的值，自然也就无法进行双向数据绑定。<br>解决方案是在操作之后执行$scope.$apply( )或者将操作的代码放在$scope.$apply(function( ){//操作的代码…})<br>二百〇八、    angular中注入方式有推断式注入、$inject注入、内联式注入，当然这三种方式在angular中是等效的，但推断式注入对于压缩的JavaScript代码来说是不起作用的，为什么？<br>因为压缩过后的 JavaScript 代码重命名了函数的参数名。在压缩js代码的时候尽量不要用推断式注入，最佳是用内联式注入的方式。<br>二百〇九、    如何看待 angular2?<br>相比Angularl.x，Angular2的改动很大，几乎算是一个全新的框架。<br>基于TypeScript (可以使用TypeScript进行开发），在大型项目团队协作时，强语言类型更有利。<br>组件化，提升开发和维护的效率。<br>还有module支持动态加载，new router，promise的原生支持等等。<br>迎合未来标准，吸纳其他框架的优点，值得期待，不过同时要学习的东西也更多了 (ES next、TS、Rx等）<br>详细参考：<br><a href="http://www.tuicool.com/articles/ymmq2mf" target="_blank" rel="noopener">http://www.tuicool.com/articles/ymmq2mf</a><br><a href="http://www.cnblogs.eom/laixiangran/p/4938732.html" target="_blank" rel="noopener">http://www.cnblogs.eom/laixiangran/p/4938732.html</a><br>综合问题<br>二百一十、    请列举你知道的前端框架？常用的前端开发工具？ 开发过哪些应用和组件？<br>(1)    前端框架<br>bootstrap/jQuery/zepto/backbone/AngularJS/vue.js/React/<br>React Native/小程序<br>(2)    前端开发工具 gulp/webpack/git/svn/npm/linux<br>    架构工具 ：bower、npm、yeoman、gulp、webpack<br>(3)    应用和组件<br>根据自己做的项目对答<br>二百一十一、    项目测试没问题。但是放到线上就有问题了，你是怎么分析解决的？<br>可能的原因：<br>(1)    后端原因：后端接口，后端服务器<br>(2)    域名、IP和路径问题<br>(3)    网络环境问题<br>(4)    线上库、框架、工具的版本和本地不一致问题<br>(5)    线上和本地数据资源不一致问题<br>(6)    程序bug<br>二百一十二、    ES6里面你用过什么？<br>1)    块作用域一let<br>2)    衡量一const<br>3)    解构数组一Array Destructuring<br>4)    解构对象一Object Destructuring<br>5)    模板字符串一Template Strings<br>6)    展开操作符<br>7)    剩余操作符<br>8)    解构参数<br>9)    箭头函数<br>10)    对象表达式<br>11)    对象属性名<br>12)    对比两个值是否相等<br>13)    把对象的值复制到另一个对象里<br>14)    设置对象的prototype<br>15)    <code>__proto__</code><br>16)    supper<br>17)    迭代器<br>18)    class 类<br>19)    get set<br>20)    静态方法<br>21)    继承<br>22)    模块化<br>细节参见：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p>
	
	</div>
	
	<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

	<!-- relate post, comment...-->
	<div class="investment-container">
		<div class="investment-header">
			<div class="investment-title-1">
				<div class="on">相关文章</div>
				<div>评论</div>
			</div>
			<div class="investment-title-2">	            
				
	<span>
		<a href="javascript: window.scrollTo(0, 0);">返回顶部</a>
		
		
			<a href="/2019/03/27/面试宝典一/" title="面试宝典一" rel="next">
				下一篇&raquo;
			</a>
			
	</span>
      		
			</div>	
		</div>
		
		<div class="investment-content">
			<div class="investment-content-list">
				

<div class="relate-post">
	<ul>
		
				<li>
					<div>
						<a href="/2019/03/27/面试宝典一/" title="面试宝典一">
							面试宝典一
						</a>
						<p>
							HTML5面试题一、    Doctype的作用? 严格模式和混杂模式的区分，以及如何触发这2种模式?&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器，用什么文档类...
						</p>
					</div>

					<a href="/2019/03/27/面试宝典一/" title="面试宝典一">				
						<img src="/img/cart_cover.jpg" class="relateImg" alt="面试宝典一">
					</a>
				</li>											
		
		
				<li>
					<div>
						<a href="/2019/03/27/变量-前端面试题/" title="变量-前端面试题">
							变量-前端面试题
						</a>
						<p>
							
知识点 var let  变量提升 暂时性死区

console.log(foo);
var foo = &quot;test&quot;;
写出上边程序的输出结果

						</p>
					</div>

					<a href="/2019/03/27/变量-前端面试题/" title="变量-前端面试题">				
						<img src="/img/cart_cover.jpg" class="relateImg" alt="变量-前端面试题">
					</a>
				</li>											
		
		
				<li>
					<div>
						<a href="/2019/03/27/this-前端面试题/" title="this-前端面试题">
							this-前端面试题
						</a>
						<p>
							


						</p>
					</div>

					<a href="/2019/03/27/this-前端面试题/" title="this-前端面试题">				
						<img src="/img/cart_cover.jpg" class="relateImg" alt="this-前端面试题">
					</a>
				</li>											
		
		
	</ul>
</div>	
			</div>
			<div class="investment-content-list">
				<div class="layout-comment">

	

		

			<!-- comment gitalk -->
			<!-- show gitalk comment -->
<div id="gitalk-container"></div>

<!-- gitalk`s css & js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<link rel="stylesheet" href="/css/comment.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="text/javascript">
	//Thanks O-R
	//https://github.com/gitalk/gitalk/issues/102#issuecomment-382970552
	//去除尾部匹配正则数组的字符串  
	//Remove redundant characters
	String.prototype.trimEnd = function(regStr) {
		var result = this;
		if(regStr == undefined || regStr == null || regStr == "") {
			return result;
		}
		var array = regStr.split(',');

		if(array.length > 0) {

			var c = array.shift();
			var str = this;
			var i = str.length;
			var rg = new RegExp(c);
			var matchArr = str.match(rg);

			if(matchArr != undefined && matchArr != null && matchArr.length > 0) {
				var matchStr = matchArr[0].replace(/\\/g, "\\\\").replace(/\*/g, "\\*")
					.replace(/\+/g, "\\+").replace(/\|/g, "\\|")
					.replace(/\{/g, "\\{").replace(/\}/g, "\\}")
					.replace(/\(/g, "\\(").replace(/\)/g, "\\)")
					.replace(/\^/g, "\\^").replace(/\$/g, "\\$")
					.replace(/\[/g, "\\[").replace(/\]/g, "\\]")
					.replace(/\?/g, "\\?").replace(/\,/g, "\\,")
					.replace(/\./g, "\\.").replace(/\&/g, "\\&");
				matchStr = matchStr + '$';
				result = str.replace(new RegExp(matchStr), "");
			}

			if(array.length > 0) {
				return result.trimEnd(array.join())
			} else {
				return result;
			}
		}
	};

	//Create gitalk
	var gitalk = new Gitalk({
		clientID: 'f015112af3b8fcf72123',
		clientSecret: '1328483e7a49433c4d3250b6508b33b86b9ef91a',
		//id: window.location.pathname,
		//id: decodeURI(window.location.pathname),
		//id: (window.location.pathname).split("/").pop().substring(0, 49),
		id: decodeURI( md5( location.href.trimEnd('#.*$,\\?.*$,index.html$') ) ),
		repo: 'ccOnTheWay-gitalk',
		owner: 'ccOnTheWay',
		admin: 'ccOnTheWay',
		distractionFreeMode: 'true',
	})
	gitalk.render('gitalk-container');
</script>

		
		
	

</div>
			</div>
		</div>	
	</div>
</div>



	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->



	<script>
		var appid = 'dX--',
            appkey = 'dx--';	  
        AnnieLeancloud(appid, appkey);         
	</script>
    


 

<!-- show math formula -->




<!-- TODO: There seems to be a bug when you close the post gallery! -->
<link rel="stylesheet" href="/plugin/lightgallery/css/lightgallery.css">
<script src="/plugin/lightgallery/js/jquery-1.11.0.min.js"></script>
<script src="/plugin/lightgallery/js/lightgallery-all.min.js"></script>

<script type="text/javascript">
	var postTitle = $('.article-title a').text() ? $('.article-title a').text() : "No post title!";
	$('.article-content img').each(function() {
		var imgPath = $(this).attr('src'),
			imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		$(this).wrap('<div class="img-responsive" data-src="' + imgPath + '" data-responsive="' + imgPath + '" data-sub-html="<p>图片 ' + imgTitle + '</p><h4>文章' + postTitle + '</h4>"></div>');
	});

	$('.article-content').lightGallery({
		mode: 'lg-slide',
		selector: '.img-responsive',
		share: false,
		zoom: false,
		download: false
	});
	//TODO：支持video
</script>

<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->
	
		</main>
		
		<!--footer-->
		<footer>
	<div class="social">
		<ul>
	
		
			<li>
				<a href="https://github.com/ccOnTheWay/wiki" title="Github" target="_blank">
					<i class="fa fa-github"></i>
				</a>
			</li>
		
		
		
			<li>
				<a href="mailto:fengxicai@fengxicai.cn" title="Email" target="_blank">
					<i class="fa fa-envelope-o"></i>
				</a>
			</li>
		

		
		
	 
</ul>
	</div>
		
	<div class="copyright">
		<p>
			 
				&copy;2019, content by FXC. All Rights Reserved.
			
			
			

	<!-- busuanzi -->
	<!-- busuanzi -->

		
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

		<span id="busuanzi_container_page_pv">
	  		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
		</span>

	




		</p>
		<!-- <p>
			<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay. 					
		</p> -->
	</div>		
</footer>
		
    <!-- set '1' to show motto in all pages! -->

	<script src="/js/motto.js"></script>
	<script type="text/javascript">
		$(".motto").html( getMingYanContent() );
	</script>	




    <!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup">
	<div class="local-search-container">
		<span class="popup-btn-close">
      ESC
   </span>
		<div class="local-search-header">
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			

   
	<div id="topN"></div>
	
    <script>
        var appid = 'dX--',
            appkey = 'dx--',
            limitCount = 10;
        if( $('#topN').length ){
            AV.initialize(appid, appkey);
            var Counter = AV.Object.extend("Counter");  
            topNPost(Counter, limitCount);
        }
    </script>
   

		</div>
	</div>
</div>

<script src="/js/ziploader.js"></script>
<script src="/js/search.js"></script>

<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>



    <script src="/js/love.js"></script>


<!--back to top-->

    
	<div id="totop">
  		<a href="javascript:;" name="TOTOP" class="fa fa-arrow-up"></a>
	</div>
	<div id="tobuttom">
		<a href="javascript:;" name="TOBUTTOM" class="fa fa-arrow-down"></a>
	</div>
 


 

<script src="/js/vibrant.js"></script>
<script src="/js/chinese.js"></script>
<script src="/js/main.js"></script>
	</body>
	</html>
