{"meta":{"title":"前端进阶之路","subtitle":null,"description":null,"author":"FXC","url":"https://github.com/ccOnTheWay/wiki.git","root":"/"},"pages":[{"title":"categories","date":"2019-03-27T02:09:33.000Z","updated":"2019-03-27T02:09:52.266Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-27T02:10:17.000Z","updated":"2020-06-10T13:53:41.935Z","comments":true,"path":"about/index.html","permalink":"https://github.com/ccOnTheWay/wiki.git/about/index.html","excerpt":"","text":"一只进阶中的前端菜鸟 放松一下 自我介绍 Name: FXC WeChat: fengxicai1 Email: fengxicai@fengxicai.cn Age: 26 Job: Front End Engineer Graduated from: Nanshan college, yantai"},{"title":"tags","date":"2019-03-27T02:10:01.000Z","updated":"2019-03-27T02:10:08.861Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端面试大纲","slug":"前端面试大纲","date":"2019-04-11T08:01:13.000Z","updated":"2019-04-11T08:20:38.428Z","comments":true,"path":"2019/04/11/前端面试大纲/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/11/前端面试大纲/","excerpt":"","text":"JS基础JS 类型 原始类型 存在着6种原始值， 分别为： boolean null undefined number string symbol 对象Object 类型","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/面试/"}]},{"title":"svg","slug":"svg","date":"2019-04-09T00:11:01.000Z","updated":"2019-04-09T00:17:16.926Z","comments":true,"path":"2019/04/09/svg/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/09/svg/","excerpt":"","text":"动画元素 SVG动画元素共有4个，包括：&lt;set&gt;、&lt;animate&gt;、&lt;animateTransform&gt;、&lt;animateMotion&gt;","categories":[],"tags":[]},{"title":"webpack","slug":"webpack","date":"2019-04-09T00:06:13.000Z","updated":"2019-04-09T00:06:13.121Z","comments":true,"path":"2019/04/09/webpack/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/09/webpack/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"threeJS","slug":"threeJS","date":"2019-04-08T11:55:59.000Z","updated":"2019-04-08T11:55:59.660Z","comments":true,"path":"2019/04/08/threeJS/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/08/threeJS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CSS3","slug":"CSS3","date":"2019-04-08T11:55:38.000Z","updated":"2019-04-09T00:35:34.922Z","comments":true,"path":"2019/04/08/CSS3/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/08/CSS3/","excerpt":"","text":"CSS 2D/动画/3D 位置、大小、旋转、透明度、阴影 transition过渡transition 有这样几个属性：transition-property:属性（哪个属性参与过渡）; transition-duration:指过渡的持续时间； transition-delay:延迟过渡时间； transition-timing-function:过渡的函数（ease | liner | ease-in | ease-out | ease-in-out | cubic-bezier）; transform变形transform:skew(X轴平移，Y轴平移) ； transform:scalse(X轴缩放，Y轴缩放); transform:rotate(旋转)； transform:translate(X轴偏移，Y轴偏移); animations 动画；@-webkit-keyframes 名字 {} 这个是定义动画的方法；我们要用这个语句来描述一个动画是怎样的。动画的名称是我们自己定义的。","categories":[{"name":"css","slug":"css","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/css/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/css3/"},{"name":"css","slug":"css","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/css/"}]},{"title":"ssr科学上网","slug":"ssr科学上网","date":"2019-04-08T02:43:16.000Z","updated":"2019-04-16T09:26:18.627Z","comments":true,"path":"2019/04/08/ssr科学上网/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/08/ssr科学上网/","excerpt":"","text":"ssr 科学上网 邀请码：930464http://poro.fun/user 蓝灯下载https://github.com/getlantern/download","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/工具/"}],"tags":[{"name":"ssr","slug":"ssr","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/ssr/"},{"name":"科学上网","slug":"科学上网","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/科学上网/"}]},{"title":"CSS-Flex","slug":"CSS-Flex","date":"2019-04-06T06:55:25.000Z","updated":"2019-04-06T07:03:54.291Z","comments":true,"path":"2019/04/06/CSS-Flex/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/06/CSS-Flex/","excerpt":"","text":"","categories":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/CSS/"},{"name":"Flex","slug":"Flex","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/Flex/"}]},{"title":"React面试整理","slug":"React面试整理","date":"2019-04-06T06:55:25.000Z","updated":"2019-04-09T12:17:58.896Z","comments":true,"path":"2019/04/06/React面试整理/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/06/React面试整理/","excerpt":"","text":"React 面试整理 react 版本 v16 React 组件的生命周期class Component 和 Function Component 的区别 ？ 什么情况下不用类组件和函数组件是什么？refs的作用是什么？React 中 keys 的作用是什么？受控组件（Controlled 与 Uncontrolled ）及非受控组件的区别，场景及使用React.children.map 和 props.children.mapcreateElement 与 cloneElement 的区别？setState 的第二个参数的作用是什么？同步更新的策略是什么？Flux 与 Redux","categories":[{"name":"React","slug":"React","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/前端框架/"}]},{"title":"面试小册-JS基础2","slug":"面试小册-JS基础2","date":"2019-04-03T01:41:38.000Z","updated":"2019-04-04T03:05:33.484Z","comments":true,"path":"2019/04/03/面试小册-JS基础2/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/03/面试小册-JS基础2/","excerpt":"","text":"面试小册-JS基础2 == vs === 涉及面试题：== 和 === 有什么区别？ 对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换，这也就用到了我们上一章节讲的内容。 假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程： 首先会判断两者类型是否相同。相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number 1 == '1' ↓ 1 == 1 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断 '1' == true ↓ '1' == 1 ↓ 1 == 1 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断 '1' == { name: 'yck' } ↓ '1' == '[object Object]' 标准文档： https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1 闭包 涉及面试题: 什么是闭包？ 闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。 function A() { let a = 1 window.B = function () { console.log(a) } } A() B() // 1 在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量 经典面试题，循环中使用闭包解决 var 定义函数的问题 for (var i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) } 首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法有三种，第一种是使用闭包的方式 for (var i = 1; i &lt;= 5; i++) { (function(j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i) } 在上述代码中，我们首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。 第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。 for (var i = 1; i &lt;= 5; i++) { setTimeout( function timer(j) { console.log(j) }, i * 1000, i ) } 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式 for (let i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) } 深浅拷贝 涉及面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？ 对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题 let a = { age: 1 } let b = a a.age = 2 console.log(b.age) // 2 浅拷贝首先可以通过 Object.assign 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。 let a = { age: 1 } let b = Object.assign({}, a) a.age = 2 console.log(b.age) // 1 ) 通过展开运算符 … 来实现浅拷贝 let a = { age: 1, jobs: { first: &#39;FE&#39; } } let b = { ...a } a.jobs.first = &#39;native&#39; console.log(b.jobs.first) // native 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。 深拷贝这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 let obj = { a: 1, b: { c: 2, d: 3, }, } obj.c = obj.b obj.e = obj.a obj.b.c = obj.c obj.b.d = obj.b obj.b.e = obj.b.c let newObj = JSON.parse(JSON.stringify(obj)) console.log(newObj) 如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝 在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化 let a = { age: undefined, sex: Symbol('male'), jobs: function() {}, name: 'yck' } let b = JSON.parse(JSON.stringify(a)) console.log(b) // {name: \"yck\"} 你会发现在上述情况中，该方法会忽略掉函数和 undefined 。但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel function structuralClone(obj) { return new Promise(resolve => { const { port1, port2 } = new MessageChannel() port2.onmessage = ev => resolve(ev.data) port1.postMessage(obj) }) } var obj = { a: 1, b: { c: 2 } } obj.b.d = obj.b // 注意该方法是异步的 // 可以处理 undefined 和循环引用对象 const test = async () => { const clone = await structuralClone(obj) console.log(clone) } test() 当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 lodash 的深拷贝函数。 function deepClone(obj) { function isObject(o) { return (typeof o === 'object' || typeof o === 'function') &amp;&amp; o !== null } if (!isObject(obj)) { throw new Error('非对象') } let isArray = Array.isArray(obj) let newObj = isArray ? [...obj] : { ...obj } Reflect.ownKeys(newObj).forEach(key => { newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key] }) return newObj } let obj = { a: [1, 2, 3], b: { c: 2, d: 3 } } let newObj = deepClone(obj) newObj.b.c = 1 console.log(obj.b.c) // 2 原型 涉及面试题：如何理解原型？如何理解原型链？ 当我们创建一个对象时 let obj = { age: 25 }，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？ 当我们在浏览器中打印 obj 时你会发现，在 obj 上居然还有一个 __proto__ 属性，那么看来之前的疑问就和这个属性有关系了。 其实每个 JS 对象都有 __proto__ 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 [[prototype]] 来实现的一个东西。 讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 __proto__ 里面有什么吧。 打开 constructor 属性我们又可以发现其中还有一个 prototype 属性，并且这个属性对应的值和先前我们在__proto__中看到的一模一样。所以我们又可以得出一个结论：原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，Function.prototype.bind() 就没有这个属性。 其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链 看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 proto 的方式连接了起来。为什么 obj 可以访问到 valueOf 函数，就是因为 obj 通过原型链找到了 valueOf 函数。 对于这一小节的知识点，总结起来就是以下几点： Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 函数的 prototype 是一个对象 对象的 __proto__ 属性指向原型， __proto__将对象和原型连接起来组成了原型链","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/面试/"},{"name":"JS","slug":"JS","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/JS/"}]},{"title":"LICEcap录屏插件","slug":"LICEcap录屏插件","date":"2019-04-01T11:09:44.000Z","updated":"2019-04-08T11:54:53.724Z","comments":true,"path":"2019/04/01/LICEcap录屏插件/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/04/01/LICEcap录屏插件/","excerpt":"","text":"LICEcap 录屏插件下载地址 https://pan.baidu.com/s/1JEowcMCnpbk_pQP2R9jC_A 提取码tvrp LTCEcap 录屏插件使用 选择需要录屏的区域点击Record Max FPS是对于录制的GIF画面清晰度的，FPS越高，GIF图的内存就越大 下面的SIZE，是询问你需要录制多少的范围，这个可以手动改正，也可以通过鼠标直接来缩放比例 选择保存地址 录屏结束选择stop OK~ 一张动态gif图实现~ 录屏结果如下~ 其它使用 VScode 插件 vs-picgo 传图到七牛云上https://tophat.top/posts/51a82223.html 录屏插件使用~~~~ 开发写博客神器~ 录屏插件使用测试~ let’s GO~","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/工具/"}],"tags":[{"name":"其它 效率","slug":"其它-效率","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/其它-效率/"}]},{"title":"js 经典面试题","slug":"js经典面试题","date":"2019-03-27T04:44:06.000Z","updated":"2019-04-24T03:04:56.910Z","comments":true,"path":"2019/03/27/js经典面试题/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/03/27/js经典面试题/","excerpt":"","text":"for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(new Date, i); }, 1000); } console.log(new Date, i); 执行输出 2017-03-18T00:43:45.873Z 5 2017-03-18T00:43:46.866Z 5 2017-03-18T00:43:46.868Z 5 2017-03-18T00:43:46.868Z 5 2017-03-18T00:43:46.868Z 5 2017-03-18T00:43:46.868Z 5 作者：王仕军链接：https://juejin.im/post/58cf180b0ce4630057d6727c来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/面试/"},{"name":"JS","slug":"JS","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/JS/"}]},{"title":"面试小册-JS基础1","slug":"面试小册-JS基础1","date":"2019-03-27T04:44:06.000Z","updated":"2019-04-03T03:40:13.806Z","comments":true,"path":"2019/03/27/面试小册-JS基础1/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2019/03/27/面试小册-JS基础1/","excerpt":"","text":"面试小册-JS基础1原始（Primitive）类型 涉及面试题：原始类型有哪几种？null 是对象嘛？ 在 JS 中，存在着 6 种原始值，分别是： boolean null undefined number string symbol 首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString() 此时你肯定会有疑问，这不对呀，明明 &#39;1&#39;.toString() 是可以使用的。其实在这种情况下，&#39;1&#39; 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。 除了会在必要的情况下强转类型以外，原始类型还有一些坑。 其中 JS 的 number 类型是浮点类型的，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3。string 类型是不可变的，无论你在 string 类型上调用何种方法，都不会对值有改变。 另外对于 null 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 typeof null会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 对象（ Object）类型涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？ 在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。 const a = [] 对于常量a来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001，再看以下代码 const a = [] const b = a b.push(1) 当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量b存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。 接下来我们来看函数参数是对象的情况 function test(person) { person.age = 26 person = { name: &#39;yyy&#39;, age: 30 } return person } const p1 = { name: &#39;yck&#39;, age: 25 } const p2 = test(p1) console.log(p1) // -&gt; ? console.log(p2) // -&gt; ? 对于以上代码，你是否能正确的写出结果呢？接下来让我为你解析一番： 首先，函数传参是传递对象指针的副本到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了但是当我们重新为 person 分配了一个对象时就出现了分歧，请看下图 所以最后 person拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的。 typeof vs instanceof 涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？ typeof 对于原始类型来说，除了 null 都可以显示正确的类型 typeof 1 // &#39;number&#39; typeof &#39;1&#39; // &#39;string&#39; typeof undefined // &#39;undefined&#39; typeof true // &#39;boolean&#39; typeof Symbol() // &#39;symbol&#39; typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型 typeof [] // &#39;object&#39; typeof {} // &#39;object&#39; typeof console.log // &#39;function&#39; 如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 instanceof。 const Person = function() {} const p1 = new Person() p1 instanceof Person // true var str = &#39;hello world&#39; str instanceof String // false var str1 = new String(&#39;hello world&#39;) str1 instanceof String // true 对于原始类型来说，你想直接通过 instanceof 来判断类型是不行的，当然我们还是有办法让 instanceof 判断原始类型的 class PrimitiveString { static [Symbol.hasInstance](x) { return typeof x === &#39;string&#39; } } console.log(&#39;hello world&#39; instanceof PrimitiveString) // true 你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能让我们自定义 instanceof 行为的东西，以上代码等同于 typeof &#39;hello world&#39; === &#39;string&#39;，所以结果自然是 true 了。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。 类型转换 涉及面试题：该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。 首先我们要知道，在 JS 中类型转换只有三种情况，分别是： 转换为布尔值 转换为数字 转换为字符串我们先来看一个类型转换表格，然后再进入正题 转Boolean在条件判断时，除了 undefined， null， false， NaN， &#39;&#39;， 0，-0，其他所有值都转为 true，包括所有对象。 对象转原始类型对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下： 如果已经是原始类型了，那就不需要转换了调用 x.valueOf()，如果转换为基础类型，就返回转换的值调用 x.toString()，如果转换为基础类型，就返回转换的值如果都没有返回原始类型，就会报错当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。 let a = { valueOf() { return 0 }, toString() { return &#39;1&#39; }, [Symbol.toPrimitive]() { return 2 } } 1 + a // =&gt; 3 四则运算符加法运算符不同于其他几个运算符，它有以下几个特点： 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 1 + &#39;1&#39; // &#39;11&#39; true + true // 2 4 + [1,2,3] // &quot;41,2,3&quot; 如果你对于答案有疑问的话，请看解析： 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 ‘11’ 对于第二行代码来说，触发特点二，所以将 true 转为数字 1 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3 另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’ &#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot; 因为 + &#39;b&#39;等于 NaN，所以结果为 &quot;aNaN&quot;，你可能也会在一些代码中看到过 + &#39;1&#39; 的形式来快速获取 number 类型。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 4 * &#39;3&#39; // 12 4 * [] // 0 4 * [1, 2] // NaN 比较运算符如果是对象，就通过 toPrimitive 转换对象如果是字符串，就通过 unicode 字符索引来比较 let a = { valueOf() { return 0 }, toString() { return &#39;1&#39; } } a &gt; -1 // true 在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。 this 涉及面试题：如何正确判断 this？箭头函数的 this是什么？ this 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 this 这个概念的。 我们先来看几个函数调用的场景 function foo() { console.log(this.a) } var a = 1 foo() const obj = { a: 2, foo: foo } obj.foo() const c = new foo() 接下来我们一个个分析上面几个场景 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this function a() { return () =&gt; { return () =&gt; { console.log(this) } } } console.log(a()()()) 首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。 最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。 那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？ let a = {} let fn = function () { console.log(this) } fn.bind().bind(a)() // =&gt; ? 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式 // fn.bind().bind(a) 等于 let fn2 = function fn1() { return function() { return fn.apply() }.apply(a) } fn2() 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。 let a = { name: &#39;yck&#39; } function foo() { console.log(this.name) } foo.bind(a)() // =&gt; &#39;yck&#39; 以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/面试/"},{"name":"JS","slug":"JS","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/JS/"}]},{"title":"Ng学习笔记 一","slug":"Ng笔记（一）","date":"2018-03-02T14:43:16.000Z","updated":"2019-04-19T01:09:57.914Z","comments":true,"path":"2018/03/02/Ng笔记（一）/","link":"","permalink":"https://github.com/ccOnTheWay/wiki.git/2018/03/02/Ng笔记（一）/","excerpt":"","text":"","categories":[{"name":"angular","slug":"angular","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/angular/"}],"tags":[]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/面试/"},{"name":"css","slug":"css","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/css/"},{"name":"工具","slug":"工具","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/工具/"},{"name":"CSS","slug":"CSS","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/CSS/"},{"name":"React","slug":"React","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/React/"},{"name":"angular","slug":"angular","permalink":"https://github.com/ccOnTheWay/wiki.git/categories/angular/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/面试/"},{"name":"css3","slug":"css3","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/css3/"},{"name":"css","slug":"css","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/css/"},{"name":"ssr","slug":"ssr","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/ssr/"},{"name":"科学上网","slug":"科学上网","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/科学上网/"},{"name":"CSS","slug":"CSS","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/CSS/"},{"name":"Flex","slug":"Flex","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/Flex/"},{"name":"React","slug":"React","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/前端框架/"},{"name":"JS","slug":"JS","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/JS/"},{"name":"其它 效率","slug":"其它-效率","permalink":"https://github.com/ccOnTheWay/wiki.git/tags/其它-效率/"}]}